enum SpanPosition {
    AFTER
    BEFORE
}

enum InputType {
    TEXT
    OPTIONS
    SATISFACTION
    YESNO
}

type Span {
    id: ID!
    where: SpanPosition!
    at: String
    text: String!
}

interface QuestionInput {
    id: ID!
    type: InputType!
    defaults: [String!]!
    multiple: Boolean
}

type TextInput implements QuestionInput {
    expected: String
    maxChars: Int
}

type SatisfactionOption {
    feeling: Int
    value: String
}

type SatisfactionInput implements QuestionInput {
    options: [SatisfactionOption!]!
}

type OptionsInput implements QuestionInput {
    alternatives: [String!]!
    multipleSelection: Boolean
}

type YesNoInput implements QuestionInput {
    triplet: Boolean!
}

type Question {
    id: ID!
    order: Int! @search
    hash: String! @search(by: [hash])
    title: String! @search(by: [term, fulltext])
    anonymous: Boolean
    input: [QuestionInput!]!
    parent: Survey! @hasInverse(field: questions)
    answer: Answer @hasInverse(field: question)
}

type Survey {
    id: ID!
    title: String! @search(by: [term])
    spans: [Span!]!
    questions: [Question!]! @hasInverse(field: parent)
}

enum UserDevice {
    PHONE
    LAPTOP
    TABLET
    OTHER
}

type IPLockup {
    ip: String! @search(by: [hash])
    city: String
    region: String
    regionCode: String
    country: String
    countryCode: String
    latitude: Float
    longitude: Float
    timezone: String
    asn: String
    org: String
}

type User {
    id: ID!
    sub: String!
    origin: String!
    email: String! @id
    domain: String!

    device: UserDevice!
    ip: IPLockup
}

type Answer {
    id: ID!
    question: Question! @hasInverse(field: answer)
    at: DateTime! @search
    by: User!
    responses: [String!]! @search(by: [fulltext])
}
