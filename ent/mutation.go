// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/minskylab/collecta/ent/account"
	"github.com/minskylab/collecta/ent/answer"
	"github.com/minskylab/collecta/ent/contact"
	"github.com/minskylab/collecta/ent/device"
	"github.com/minskylab/collecta/ent/domain"
	"github.com/minskylab/collecta/ent/flow"
	"github.com/minskylab/collecta/ent/input"
	"github.com/minskylab/collecta/ent/ip"
	"github.com/minskylab/collecta/ent/person"
	"github.com/minskylab/collecta/ent/question"
	"github.com/minskylab/collecta/ent/short"
	"github.com/minskylab/collecta/ent/survey"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount  = "Account"
	TypeAnswer   = "Answer"
	TypeContact  = "Contact"
	TypeDatum    = "Datum"
	TypeDevice   = "Device"
	TypeDomain   = "Domain"
	TypeFlow     = "Flow"
	TypeIP       = "IP"
	TypeInput    = "Input"
	TypePerson   = "Person"
	TypeQuestion = "Question"
	TypeShort    = "Short"
	TypeSurvey   = "Survey"
)

// AccountMutation represents an operation that mutate the Accounts
// nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	_type         *account.Type
	sub           *string
	remoteID      *string
	secret        *string
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
}

var _ ent.Mutation = (*AccountMutation)(nil)

// newAccountMutation creates new mutation for $n.Name.
func newAccountMutation(c config, op Op) *AccountMutation {
	return &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Account creation.
func (m *AccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *AccountMutation) SetType(a account.Type) {
	m._type = &a
}

// GetType returns the type value in the mutation.
func (m *AccountMutation) GetType() (r account.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the type field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetSub sets the sub field.
func (m *AccountMutation) SetSub(s string) {
	m.sub = &s
}

// Sub returns the sub value in the mutation.
func (m *AccountMutation) Sub() (r string, exists bool) {
	v := m.sub
	if v == nil {
		return
	}
	return *v, true
}

// ResetSub reset all changes of the sub field.
func (m *AccountMutation) ResetSub() {
	m.sub = nil
}

// SetRemoteID sets the remoteID field.
func (m *AccountMutation) SetRemoteID(s string) {
	m.remoteID = &s
}

// RemoteID returns the remoteID value in the mutation.
func (m *AccountMutation) RemoteID() (r string, exists bool) {
	v := m.remoteID
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemoteID reset all changes of the remoteID field.
func (m *AccountMutation) ResetRemoteID() {
	m.remoteID = nil
}

// SetSecret sets the secret field.
func (m *AccountMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the secret value in the mutation.
func (m *AccountMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// ClearSecret clears the value of secret.
func (m *AccountMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[account.FieldSecret] = struct{}{}
}

// SecretCleared returns if the field secret was cleared in this mutation.
func (m *AccountMutation) SecretCleared() bool {
	_, ok := m.clearedFields[account.FieldSecret]
	return ok
}

// ResetSecret reset all changes of the secret field.
func (m *AccountMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, account.FieldSecret)
}

// SetOwnerID sets the owner edge to Person by id.
func (m *AccountMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Person.
func (m *AccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *AccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *AccountMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the owner edge.
func (m *AccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.sub != nil {
		fields = append(fields, account.FieldSub)
	}
	if m.remoteID != nil {
		fields = append(fields, account.FieldRemoteID)
	}
	if m.secret != nil {
		fields = append(fields, account.FieldSecret)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldType:
		return m.GetType()
	case account.FieldSub:
		return m.Sub()
	case account.FieldRemoteID:
		return m.RemoteID()
	case account.FieldSecret:
		return m.Secret()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldType:
		v, ok := value.(account.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldSub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSub(v)
		return nil
	case account.FieldRemoteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteID(v)
		return nil
	case account.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldSecret) {
		fields = append(fields, account.FieldSecret)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldSecret:
		m.ClearSecret()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldSub:
		m.ResetSub()
		return nil
	case account.FieldRemoteID:
		m.ResetRemoteID()
		return nil
	case account.FieldSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, account.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, account.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AnswerMutation represents an operation that mutate the Answers
// nodes in the graph.
type AnswerMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	at              *time.Time
	responses       *[]string
	valid           *bool
	clearedFields   map[string]struct{}
	question        *uuid.UUID
	clearedquestion bool
}

var _ ent.Mutation = (*AnswerMutation)(nil)

// newAnswerMutation creates new mutation for $n.Name.
func newAnswerMutation(c config, op Op) *AnswerMutation {
	return &AnswerMutation{
		config:        c,
		op:            op,
		typ:           TypeAnswer,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnswerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnswerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Answer creation.
func (m *AnswerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AnswerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAt sets the at field.
func (m *AnswerMutation) SetAt(t time.Time) {
	m.at = &t
}

// At returns the at value in the mutation.
func (m *AnswerMutation) At() (r time.Time, exists bool) {
	v := m.at
	if v == nil {
		return
	}
	return *v, true
}

// ResetAt reset all changes of the at field.
func (m *AnswerMutation) ResetAt() {
	m.at = nil
}

// SetResponses sets the responses field.
func (m *AnswerMutation) SetResponses(s []string) {
	m.responses = &s
}

// Responses returns the responses value in the mutation.
func (m *AnswerMutation) Responses() (r []string, exists bool) {
	v := m.responses
	if v == nil {
		return
	}
	return *v, true
}

// ResetResponses reset all changes of the responses field.
func (m *AnswerMutation) ResetResponses() {
	m.responses = nil
}

// SetValid sets the valid field.
func (m *AnswerMutation) SetValid(b bool) {
	m.valid = &b
}

// Valid returns the valid value in the mutation.
func (m *AnswerMutation) Valid() (r bool, exists bool) {
	v := m.valid
	if v == nil {
		return
	}
	return *v, true
}

// ClearValid clears the value of valid.
func (m *AnswerMutation) ClearValid() {
	m.valid = nil
	m.clearedFields[answer.FieldValid] = struct{}{}
}

// ValidCleared returns if the field valid was cleared in this mutation.
func (m *AnswerMutation) ValidCleared() bool {
	_, ok := m.clearedFields[answer.FieldValid]
	return ok
}

// ResetValid reset all changes of the valid field.
func (m *AnswerMutation) ResetValid() {
	m.valid = nil
	delete(m.clearedFields, answer.FieldValid)
}

// SetQuestionID sets the question edge to Question by id.
func (m *AnswerMutation) SetQuestionID(id uuid.UUID) {
	m.question = &id
}

// ClearQuestion clears the question edge to Question.
func (m *AnswerMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared returns if the edge question was cleared.
func (m *AnswerMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionID returns the question id in the mutation.
func (m *AnswerMutation) QuestionID() (id uuid.UUID, exists bool) {
	if m.question != nil {
		return *m.question, true
	}
	return
}

// QuestionIDs returns the question ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *AnswerMutation) QuestionIDs() (ids []uuid.UUID) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion reset all changes of the question edge.
func (m *AnswerMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// Op returns the operation name.
func (m *AnswerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Answer).
func (m *AnswerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AnswerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.at != nil {
		fields = append(fields, answer.FieldAt)
	}
	if m.responses != nil {
		fields = append(fields, answer.FieldResponses)
	}
	if m.valid != nil {
		fields = append(fields, answer.FieldValid)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AnswerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case answer.FieldAt:
		return m.At()
	case answer.FieldResponses:
		return m.Responses()
	case answer.FieldValid:
		return m.Valid()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AnswerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case answer.FieldAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAt(v)
		return nil
	case answer.FieldResponses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponses(v)
		return nil
	case answer.FieldValid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValid(v)
		return nil
	}
	return fmt.Errorf("unknown Answer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AnswerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AnswerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AnswerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Answer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AnswerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(answer.FieldValid) {
		fields = append(fields, answer.FieldValid)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AnswerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnswerMutation) ClearField(name string) error {
	switch name {
	case answer.FieldValid:
		m.ClearValid()
		return nil
	}
	return fmt.Errorf("unknown Answer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AnswerMutation) ResetField(name string) error {
	switch name {
	case answer.FieldAt:
		m.ResetAt()
		return nil
	case answer.FieldResponses:
		m.ResetResponses()
		return nil
	case answer.FieldValid:
		m.ResetValid()
		return nil
	}
	return fmt.Errorf("unknown Answer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AnswerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question != nil {
		edges = append(edges, answer.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AnswerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case answer.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AnswerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AnswerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AnswerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion {
		edges = append(edges, answer.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AnswerMutation) EdgeCleared(name string) bool {
	switch name {
	case answer.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AnswerMutation) ClearEdge(name string) error {
	switch name {
	case answer.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown Answer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AnswerMutation) ResetEdge(name string) error {
	switch name {
	case answer.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown Answer edge %s", name)
}

// ContactMutation represents an operation that mutate the Contacts
// nodes in the graph.
type ContactMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	value         *string
	kind          *contact.Kind
	principal     *bool
	validated     *bool
	fromAccount   *bool
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
}

var _ ent.Mutation = (*ContactMutation)(nil)

// newContactMutation creates new mutation for $n.Name.
func newContactMutation(c config, op Op) *ContactMutation {
	return &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Contact creation.
func (m *ContactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ContactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *ContactMutation) ResetName() {
	m.name = nil
}

// SetValue sets the value field.
func (m *ContactMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value value in the mutation.
func (m *ContactMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue reset all changes of the value field.
func (m *ContactMutation) ResetValue() {
	m.value = nil
}

// SetKind sets the kind field.
func (m *ContactMutation) SetKind(c contact.Kind) {
	m.kind = &c
}

// Kind returns the kind value in the mutation.
func (m *ContactMutation) Kind() (r contact.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// ResetKind reset all changes of the kind field.
func (m *ContactMutation) ResetKind() {
	m.kind = nil
}

// SetPrincipal sets the principal field.
func (m *ContactMutation) SetPrincipal(b bool) {
	m.principal = &b
}

// Principal returns the principal value in the mutation.
func (m *ContactMutation) Principal() (r bool, exists bool) {
	v := m.principal
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrincipal reset all changes of the principal field.
func (m *ContactMutation) ResetPrincipal() {
	m.principal = nil
}

// SetValidated sets the validated field.
func (m *ContactMutation) SetValidated(b bool) {
	m.validated = &b
}

// Validated returns the validated value in the mutation.
func (m *ContactMutation) Validated() (r bool, exists bool) {
	v := m.validated
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidated reset all changes of the validated field.
func (m *ContactMutation) ResetValidated() {
	m.validated = nil
}

// SetFromAccount sets the fromAccount field.
func (m *ContactMutation) SetFromAccount(b bool) {
	m.fromAccount = &b
}

// FromAccount returns the fromAccount value in the mutation.
func (m *ContactMutation) FromAccount() (r bool, exists bool) {
	v := m.fromAccount
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromAccount reset all changes of the fromAccount field.
func (m *ContactMutation) ResetFromAccount() {
	m.fromAccount = nil
}

// SetOwnerID sets the owner edge to Person by id.
func (m *ContactMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Person.
func (m *ContactMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *ContactMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *ContactMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the owner edge.
func (m *ContactMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, contact.FieldName)
	}
	if m.value != nil {
		fields = append(fields, contact.FieldValue)
	}
	if m.kind != nil {
		fields = append(fields, contact.FieldKind)
	}
	if m.principal != nil {
		fields = append(fields, contact.FieldPrincipal)
	}
	if m.validated != nil {
		fields = append(fields, contact.FieldValidated)
	}
	if m.fromAccount != nil {
		fields = append(fields, contact.FieldFromAccount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldName:
		return m.Name()
	case contact.FieldValue:
		return m.Value()
	case contact.FieldKind:
		return m.Kind()
	case contact.FieldPrincipal:
		return m.Principal()
	case contact.FieldValidated:
		return m.Validated()
	case contact.FieldFromAccount:
		return m.FromAccount()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contact.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case contact.FieldKind:
		v, ok := value.(contact.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case contact.FieldPrincipal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipal(v)
		return nil
	case contact.FieldValidated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidated(v)
		return nil
	case contact.FieldFromAccount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAccount(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ContactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldName:
		m.ResetName()
		return nil
	case contact.FieldValue:
		m.ResetValue()
		return nil
	case contact.FieldKind:
		m.ResetKind()
		return nil
	case contact.FieldPrincipal:
		m.ResetPrincipal()
		return nil
	case contact.FieldValidated:
		m.ResetValidated()
		return nil
	case contact.FieldFromAccount:
		m.ResetFromAccount()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, contact.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, contact.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	switch name {
	case contact.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Contact edge %s", name)
}

// DatumMutation represents an operation that mutate the Data
// nodes in the graph.
type DatumMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
}

var _ ent.Mutation = (*DatumMutation)(nil)

// newDatumMutation creates new mutation for $n.Name.
func newDatumMutation(c config, op Op) *DatumMutation {
	return &DatumMutation{
		config:        c,
		op:            op,
		typ:           TypeDatum,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DatumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DatumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DatumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *DatumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Datum).
func (m *DatumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DatumMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DatumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DatumMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Datum field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DatumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DatumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DatumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Datum numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DatumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DatumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DatumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Datum nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DatumMutation) ResetField(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Datum field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DatumMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DatumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DatumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DatumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DatumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DatumMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DatumMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Datum unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DatumMutation) ResetEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Datum edge %s", name)
}

// DeviceMutation represents an operation that mutate the Devices
// nodes in the graph.
type DeviceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	device        *string
	clearedFields map[string]struct{}
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// newDeviceMutation creates new mutation for $n.Name.
func newDeviceMutation(c config, op Op) *DeviceMutation {
	return &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDevice sets the device field.
func (m *DeviceMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the device value in the mutation.
func (m *DeviceMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// ResetDevice reset all changes of the device field.
func (m *DeviceMutation) ResetDevice() {
	m.device = nil
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.device != nil {
		fields = append(fields, device.FieldDevice)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDevice:
		return m.Device()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DomainMutation represents an operation that mutate the Domains
// nodes in the graph.
type DomainMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	name                   *string
	email                  *string
	domain                 *string
	collectaDomain         *string
	collectaClientCallback *string
	tags                   *[]string
	clearedFields          map[string]struct{}
	surveys                map[uuid.UUID]struct{}
	removedsurveys         map[uuid.UUID]struct{}
	users                  map[uuid.UUID]struct{}
	removedusers           map[uuid.UUID]struct{}
	admins                 map[uuid.UUID]struct{}
	removedadmins          map[uuid.UUID]struct{}
}

var _ ent.Mutation = (*DomainMutation)(nil)

// newDomainMutation creates new mutation for $n.Name.
func newDomainMutation(c config, op Op) *DomainMutation {
	return &DomainMutation{
		config:        c,
		op:            op,
		typ:           TypeDomain,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Domain creation.
func (m *DomainMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DomainMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DomainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DomainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *DomainMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *DomainMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *DomainMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmail reset all changes of the email field.
func (m *DomainMutation) ResetEmail() {
	m.email = nil
}

// SetDomain sets the domain field.
func (m *DomainMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the domain value in the mutation.
func (m *DomainMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// ResetDomain reset all changes of the domain field.
func (m *DomainMutation) ResetDomain() {
	m.domain = nil
}

// SetCollectaDomain sets the collectaDomain field.
func (m *DomainMutation) SetCollectaDomain(s string) {
	m.collectaDomain = &s
}

// CollectaDomain returns the collectaDomain value in the mutation.
func (m *DomainMutation) CollectaDomain() (r string, exists bool) {
	v := m.collectaDomain
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectaDomain reset all changes of the collectaDomain field.
func (m *DomainMutation) ResetCollectaDomain() {
	m.collectaDomain = nil
}

// SetCollectaClientCallback sets the collectaClientCallback field.
func (m *DomainMutation) SetCollectaClientCallback(s string) {
	m.collectaClientCallback = &s
}

// CollectaClientCallback returns the collectaClientCallback value in the mutation.
func (m *DomainMutation) CollectaClientCallback() (r string, exists bool) {
	v := m.collectaClientCallback
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectaClientCallback reset all changes of the collectaClientCallback field.
func (m *DomainMutation) ResetCollectaClientCallback() {
	m.collectaClientCallback = nil
}

// SetTags sets the tags field.
func (m *DomainMutation) SetTags(s []string) {
	m.tags = &s
}

// Tags returns the tags value in the mutation.
func (m *DomainMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// ResetTags reset all changes of the tags field.
func (m *DomainMutation) ResetTags() {
	m.tags = nil
}

// AddSurveyIDs adds the surveys edge to Survey by ids.
func (m *DomainMutation) AddSurveyIDs(ids ...uuid.UUID) {
	if m.surveys == nil {
		m.surveys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.surveys[ids[i]] = struct{}{}
	}
}

// RemoveSurveyIDs removes the surveys edge to Survey by ids.
func (m *DomainMutation) RemoveSurveyIDs(ids ...uuid.UUID) {
	if m.removedsurveys == nil {
		m.removedsurveys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedsurveys[ids[i]] = struct{}{}
	}
}

// RemovedSurveys returns the removed ids of surveys.
func (m *DomainMutation) RemovedSurveysIDs() (ids []uuid.UUID) {
	for id := range m.removedsurveys {
		ids = append(ids, id)
	}
	return
}

// SurveysIDs returns the surveys ids in the mutation.
func (m *DomainMutation) SurveysIDs() (ids []uuid.UUID) {
	for id := range m.surveys {
		ids = append(ids, id)
	}
	return
}

// ResetSurveys reset all changes of the surveys edge.
func (m *DomainMutation) ResetSurveys() {
	m.surveys = nil
	m.removedsurveys = nil
}

// AddUserIDs adds the users edge to Person by ids.
func (m *DomainMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the users edge to Person by ids.
func (m *DomainMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *DomainMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *DomainMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the users edge.
func (m *DomainMutation) ResetUsers() {
	m.users = nil
	m.removedusers = nil
}

// AddAdminIDs adds the admins edge to Person by ids.
func (m *DomainMutation) AddAdminIDs(ids ...uuid.UUID) {
	if m.admins == nil {
		m.admins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// RemoveAdminIDs removes the admins edge to Person by ids.
func (m *DomainMutation) RemoveAdminIDs(ids ...uuid.UUID) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed ids of admins.
func (m *DomainMutation) RemovedAdminsIDs() (ids []uuid.UUID) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the admins ids in the mutation.
func (m *DomainMutation) AdminsIDs() (ids []uuid.UUID) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins reset all changes of the admins edge.
func (m *DomainMutation) ResetAdmins() {
	m.admins = nil
	m.removedadmins = nil
}

// Op returns the operation name.
func (m *DomainMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Domain).
func (m *DomainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DomainMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, domain.FieldName)
	}
	if m.email != nil {
		fields = append(fields, domain.FieldEmail)
	}
	if m.domain != nil {
		fields = append(fields, domain.FieldDomain)
	}
	if m.collectaDomain != nil {
		fields = append(fields, domain.FieldCollectaDomain)
	}
	if m.collectaClientCallback != nil {
		fields = append(fields, domain.FieldCollectaClientCallback)
	}
	if m.tags != nil {
		fields = append(fields, domain.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DomainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldName:
		return m.Name()
	case domain.FieldEmail:
		return m.Email()
	case domain.FieldDomain:
		return m.Domain()
	case domain.FieldCollectaDomain:
		return m.CollectaDomain()
	case domain.FieldCollectaClientCallback:
		return m.CollectaClientCallback()
	case domain.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DomainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case domain.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case domain.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case domain.FieldCollectaDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectaDomain(v)
		return nil
	case domain.FieldCollectaClientCallback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectaClientCallback(v)
		return nil
	case domain.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DomainMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DomainMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DomainMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DomainMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DomainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Domain nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DomainMutation) ResetField(name string) error {
	switch name {
	case domain.FieldName:
		m.ResetName()
		return nil
	case domain.FieldEmail:
		m.ResetEmail()
		return nil
	case domain.FieldDomain:
		m.ResetDomain()
		return nil
	case domain.FieldCollectaDomain:
		m.ResetCollectaDomain()
		return nil
	case domain.FieldCollectaClientCallback:
		m.ResetCollectaClientCallback()
		return nil
	case domain.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DomainMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.surveys != nil {
		edges = append(edges, domain.EdgeSurveys)
	}
	if m.users != nil {
		edges = append(edges, domain.EdgeUsers)
	}
	if m.admins != nil {
		edges = append(edges, domain.EdgeAdmins)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DomainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.surveys))
		for id := range m.surveys {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DomainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsurveys != nil {
		edges = append(edges, domain.EdgeSurveys)
	}
	if m.removedusers != nil {
		edges = append(edges, domain.EdgeUsers)
	}
	if m.removedadmins != nil {
		edges = append(edges, domain.EdgeAdmins)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DomainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.removedsurveys))
		for id := range m.removedsurveys {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DomainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DomainMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DomainMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DomainMutation) ResetEdge(name string) error {
	switch name {
	case domain.EdgeSurveys:
		m.ResetSurveys()
		return nil
	case domain.EdgeUsers:
		m.ResetUsers()
		return nil
	case domain.EdgeAdmins:
		m.ResetAdmins()
		return nil
	}
	return fmt.Errorf("unknown Domain edge %s", name)
}

// FlowMutation represents an operation that mutate the Flows
// nodes in the graph.
type FlowMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	state            *uuid.UUID
	stateTable       *string
	initialState     *uuid.UUID
	terminationState *uuid.UUID
	pastState        *uuid.UUID
	inputs           *[]string
	clearedFields    map[string]struct{}
	survey           *uuid.UUID
	clearedsurvey    bool
	questions        map[uuid.UUID]struct{}
	removedquestions map[uuid.UUID]struct{}
}

var _ ent.Mutation = (*FlowMutation)(nil)

// newFlowMutation creates new mutation for $n.Name.
func newFlowMutation(c config, op Op) *FlowMutation {
	return &FlowMutation{
		config:        c,
		op:            op,
		typ:           TypeFlow,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Flow creation.
func (m *FlowMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FlowMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetState sets the state field.
func (m *FlowMutation) SetState(u uuid.UUID) {
	m.state = &u
}

// State returns the state value in the mutation.
func (m *FlowMutation) State() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// ResetState reset all changes of the state field.
func (m *FlowMutation) ResetState() {
	m.state = nil
}

// SetStateTable sets the stateTable field.
func (m *FlowMutation) SetStateTable(s string) {
	m.stateTable = &s
}

// StateTable returns the stateTable value in the mutation.
func (m *FlowMutation) StateTable() (r string, exists bool) {
	v := m.stateTable
	if v == nil {
		return
	}
	return *v, true
}

// ResetStateTable reset all changes of the stateTable field.
func (m *FlowMutation) ResetStateTable() {
	m.stateTable = nil
}

// SetInitialState sets the initialState field.
func (m *FlowMutation) SetInitialState(u uuid.UUID) {
	m.initialState = &u
}

// InitialState returns the initialState value in the mutation.
func (m *FlowMutation) InitialState() (r uuid.UUID, exists bool) {
	v := m.initialState
	if v == nil {
		return
	}
	return *v, true
}

// ResetInitialState reset all changes of the initialState field.
func (m *FlowMutation) ResetInitialState() {
	m.initialState = nil
}

// SetTerminationState sets the terminationState field.
func (m *FlowMutation) SetTerminationState(u uuid.UUID) {
	m.terminationState = &u
}

// TerminationState returns the terminationState value in the mutation.
func (m *FlowMutation) TerminationState() (r uuid.UUID, exists bool) {
	v := m.terminationState
	if v == nil {
		return
	}
	return *v, true
}

// ResetTerminationState reset all changes of the terminationState field.
func (m *FlowMutation) ResetTerminationState() {
	m.terminationState = nil
}

// SetPastState sets the pastState field.
func (m *FlowMutation) SetPastState(u uuid.UUID) {
	m.pastState = &u
}

// PastState returns the pastState value in the mutation.
func (m *FlowMutation) PastState() (r uuid.UUID, exists bool) {
	v := m.pastState
	if v == nil {
		return
	}
	return *v, true
}

// ClearPastState clears the value of pastState.
func (m *FlowMutation) ClearPastState() {
	m.pastState = nil
	m.clearedFields[flow.FieldPastState] = struct{}{}
}

// PastStateCleared returns if the field pastState was cleared in this mutation.
func (m *FlowMutation) PastStateCleared() bool {
	_, ok := m.clearedFields[flow.FieldPastState]
	return ok
}

// ResetPastState reset all changes of the pastState field.
func (m *FlowMutation) ResetPastState() {
	m.pastState = nil
	delete(m.clearedFields, flow.FieldPastState)
}

// SetInputs sets the inputs field.
func (m *FlowMutation) SetInputs(s []string) {
	m.inputs = &s
}

// Inputs returns the inputs value in the mutation.
func (m *FlowMutation) Inputs() (r []string, exists bool) {
	v := m.inputs
	if v == nil {
		return
	}
	return *v, true
}

// ClearInputs clears the value of inputs.
func (m *FlowMutation) ClearInputs() {
	m.inputs = nil
	m.clearedFields[flow.FieldInputs] = struct{}{}
}

// InputsCleared returns if the field inputs was cleared in this mutation.
func (m *FlowMutation) InputsCleared() bool {
	_, ok := m.clearedFields[flow.FieldInputs]
	return ok
}

// ResetInputs reset all changes of the inputs field.
func (m *FlowMutation) ResetInputs() {
	m.inputs = nil
	delete(m.clearedFields, flow.FieldInputs)
}

// SetSurveyID sets the survey edge to Survey by id.
func (m *FlowMutation) SetSurveyID(id uuid.UUID) {
	m.survey = &id
}

// ClearSurvey clears the survey edge to Survey.
func (m *FlowMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared returns if the edge survey was cleared.
func (m *FlowMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyID returns the survey id in the mutation.
func (m *FlowMutation) SurveyID() (id uuid.UUID, exists bool) {
	if m.survey != nil {
		return *m.survey, true
	}
	return
}

// SurveyIDs returns the survey ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *FlowMutation) SurveyIDs() (ids []uuid.UUID) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey reset all changes of the survey edge.
func (m *FlowMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// AddQuestionIDs adds the questions edge to Question by ids.
func (m *FlowMutation) AddQuestionIDs(ids ...uuid.UUID) {
	if m.questions == nil {
		m.questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// RemoveQuestionIDs removes the questions edge to Question by ids.
func (m *FlowMutation) RemoveQuestionIDs(ids ...uuid.UUID) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed ids of questions.
func (m *FlowMutation) RemovedQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the questions ids in the mutation.
func (m *FlowMutation) QuestionsIDs() (ids []uuid.UUID) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions reset all changes of the questions edge.
func (m *FlowMutation) ResetQuestions() {
	m.questions = nil
	m.removedquestions = nil
}

// Op returns the operation name.
func (m *FlowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Flow).
func (m *FlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FlowMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.state != nil {
		fields = append(fields, flow.FieldState)
	}
	if m.stateTable != nil {
		fields = append(fields, flow.FieldStateTable)
	}
	if m.initialState != nil {
		fields = append(fields, flow.FieldInitialState)
	}
	if m.terminationState != nil {
		fields = append(fields, flow.FieldTerminationState)
	}
	if m.pastState != nil {
		fields = append(fields, flow.FieldPastState)
	}
	if m.inputs != nil {
		fields = append(fields, flow.FieldInputs)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flow.FieldState:
		return m.State()
	case flow.FieldStateTable:
		return m.StateTable()
	case flow.FieldInitialState:
		return m.InitialState()
	case flow.FieldTerminationState:
		return m.TerminationState()
	case flow.FieldPastState:
		return m.PastState()
	case flow.FieldInputs:
		return m.Inputs()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flow.FieldState:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case flow.FieldStateTable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateTable(v)
		return nil
	case flow.FieldInitialState:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialState(v)
		return nil
	case flow.FieldTerminationState:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminationState(v)
		return nil
	case flow.FieldPastState:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPastState(v)
		return nil
	case flow.FieldInputs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputs(v)
		return nil
	}
	return fmt.Errorf("unknown Flow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Flow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flow.FieldPastState) {
		fields = append(fields, flow.FieldPastState)
	}
	if m.FieldCleared(flow.FieldInputs) {
		fields = append(fields, flow.FieldInputs)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowMutation) ClearField(name string) error {
	switch name {
	case flow.FieldPastState:
		m.ClearPastState()
		return nil
	case flow.FieldInputs:
		m.ClearInputs()
		return nil
	}
	return fmt.Errorf("unknown Flow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FlowMutation) ResetField(name string) error {
	switch name {
	case flow.FieldState:
		m.ResetState()
		return nil
	case flow.FieldStateTable:
		m.ResetStateTable()
		return nil
	case flow.FieldInitialState:
		m.ResetInitialState()
		return nil
	case flow.FieldTerminationState:
		m.ResetTerminationState()
		return nil
	case flow.FieldPastState:
		m.ResetPastState()
		return nil
	case flow.FieldInputs:
		m.ResetInputs()
		return nil
	}
	return fmt.Errorf("unknown Flow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.survey != nil {
		edges = append(edges, flow.EdgeSurvey)
	}
	if m.questions != nil {
		edges = append(edges, flow.EdgeQuestions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flow.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	case flow.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedquestions != nil {
		edges = append(edges, flow.EdgeQuestions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FlowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flow.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsurvey {
		edges = append(edges, flow.EdgeSurvey)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FlowMutation) EdgeCleared(name string) bool {
	switch name {
	case flow.EdgeSurvey:
		return m.clearedsurvey
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FlowMutation) ClearEdge(name string) error {
	switch name {
	case flow.EdgeSurvey:
		m.ClearSurvey()
		return nil
	}
	return fmt.Errorf("unknown Flow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FlowMutation) ResetEdge(name string) error {
	switch name {
	case flow.EdgeSurvey:
		m.ResetSurvey()
		return nil
	case flow.EdgeQuestions:
		m.ResetQuestions()
		return nil
	}
	return fmt.Errorf("unknown Flow edge %s", name)
}

// IPMutation represents an operation that mutate the IPs
// nodes in the graph.
type IPMutation struct {
	config
	op            Op
	typ           string
	id            *int
	ip            *string
	clearedFields map[string]struct{}
}

var _ ent.Mutation = (*IPMutation)(nil)

// newIPMutation creates new mutation for $n.Name.
func newIPMutation(c config, op Op) *IPMutation {
	return &IPMutation{
		config:        c,
		op:            op,
		typ:           TypeIP,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *IPMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetIP sets the ip field.
func (m *IPMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the ip value in the mutation.
func (m *IPMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// ResetIP reset all changes of the ip field.
func (m *IPMutation) ResetIP() {
	m.ip = nil
}

// Op returns the operation name.
func (m *IPMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (IP).
func (m *IPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *IPMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.ip != nil {
		fields = append(fields, ip.FieldIP)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *IPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ip.FieldIP:
		return m.IP()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *IPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ip.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	}
	return fmt.Errorf("unknown IP field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *IPMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *IPMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *IPMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *IPMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *IPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IP nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *IPMutation) ResetField(name string) error {
	switch name {
	case ip.FieldIP:
		m.ResetIP()
		return nil
	}
	return fmt.Errorf("unknown IP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *IPMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *IPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *IPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *IPMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *IPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *IPMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *IPMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IP unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *IPMutation) ResetEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IP edge %s", name)
}

// InputMutation represents an operation that mutate the Inputs
// nodes in the graph.
type InputMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	kind            *input.Kind
	multiple        *bool
	defaults        *[]string
	options         *map[string]string
	clearedFields   map[string]struct{}
	question        *uuid.UUID
	clearedquestion bool
}

var _ ent.Mutation = (*InputMutation)(nil)

// newInputMutation creates new mutation for $n.Name.
func newInputMutation(c config, op Op) *InputMutation {
	return &InputMutation{
		config:        c,
		op:            op,
		typ:           TypeInput,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Input creation.
func (m *InputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetKind sets the kind field.
func (m *InputMutation) SetKind(i input.Kind) {
	m.kind = &i
}

// Kind returns the kind value in the mutation.
func (m *InputMutation) Kind() (r input.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// ResetKind reset all changes of the kind field.
func (m *InputMutation) ResetKind() {
	m.kind = nil
}

// SetMultiple sets the multiple field.
func (m *InputMutation) SetMultiple(b bool) {
	m.multiple = &b
}

// Multiple returns the multiple value in the mutation.
func (m *InputMutation) Multiple() (r bool, exists bool) {
	v := m.multiple
	if v == nil {
		return
	}
	return *v, true
}

// ClearMultiple clears the value of multiple.
func (m *InputMutation) ClearMultiple() {
	m.multiple = nil
	m.clearedFields[input.FieldMultiple] = struct{}{}
}

// MultipleCleared returns if the field multiple was cleared in this mutation.
func (m *InputMutation) MultipleCleared() bool {
	_, ok := m.clearedFields[input.FieldMultiple]
	return ok
}

// ResetMultiple reset all changes of the multiple field.
func (m *InputMutation) ResetMultiple() {
	m.multiple = nil
	delete(m.clearedFields, input.FieldMultiple)
}

// SetDefaults sets the defaults field.
func (m *InputMutation) SetDefaults(s []string) {
	m.defaults = &s
}

// Defaults returns the defaults value in the mutation.
func (m *InputMutation) Defaults() (r []string, exists bool) {
	v := m.defaults
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaults clears the value of defaults.
func (m *InputMutation) ClearDefaults() {
	m.defaults = nil
	m.clearedFields[input.FieldDefaults] = struct{}{}
}

// DefaultsCleared returns if the field defaults was cleared in this mutation.
func (m *InputMutation) DefaultsCleared() bool {
	_, ok := m.clearedFields[input.FieldDefaults]
	return ok
}

// ResetDefaults reset all changes of the defaults field.
func (m *InputMutation) ResetDefaults() {
	m.defaults = nil
	delete(m.clearedFields, input.FieldDefaults)
}

// SetOptions sets the options field.
func (m *InputMutation) SetOptions(value map[string]string) {
	m.options = &value
}

// Options returns the options value in the mutation.
func (m *InputMutation) Options() (r map[string]string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// ClearOptions clears the value of options.
func (m *InputMutation) ClearOptions() {
	m.options = nil
	m.clearedFields[input.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the field options was cleared in this mutation.
func (m *InputMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[input.FieldOptions]
	return ok
}

// ResetOptions reset all changes of the options field.
func (m *InputMutation) ResetOptions() {
	m.options = nil
	delete(m.clearedFields, input.FieldOptions)
}

// SetQuestionID sets the question edge to Question by id.
func (m *InputMutation) SetQuestionID(id uuid.UUID) {
	m.question = &id
}

// ClearQuestion clears the question edge to Question.
func (m *InputMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared returns if the edge question was cleared.
func (m *InputMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionID returns the question id in the mutation.
func (m *InputMutation) QuestionID() (id uuid.UUID, exists bool) {
	if m.question != nil {
		return *m.question, true
	}
	return
}

// QuestionIDs returns the question ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *InputMutation) QuestionIDs() (ids []uuid.UUID) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion reset all changes of the question edge.
func (m *InputMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// Op returns the operation name.
func (m *InputMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Input).
func (m *InputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InputMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.kind != nil {
		fields = append(fields, input.FieldKind)
	}
	if m.multiple != nil {
		fields = append(fields, input.FieldMultiple)
	}
	if m.defaults != nil {
		fields = append(fields, input.FieldDefaults)
	}
	if m.options != nil {
		fields = append(fields, input.FieldOptions)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case input.FieldKind:
		return m.Kind()
	case input.FieldMultiple:
		return m.Multiple()
	case input.FieldDefaults:
		return m.Defaults()
	case input.FieldOptions:
		return m.Options()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case input.FieldKind:
		v, ok := value.(input.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case input.FieldMultiple:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiple(v)
		return nil
	case input.FieldDefaults:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaults(v)
		return nil
	case input.FieldOptions:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	}
	return fmt.Errorf("unknown Input field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InputMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InputMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InputMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Input numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(input.FieldMultiple) {
		fields = append(fields, input.FieldMultiple)
	}
	if m.FieldCleared(input.FieldDefaults) {
		fields = append(fields, input.FieldDefaults)
	}
	if m.FieldCleared(input.FieldOptions) {
		fields = append(fields, input.FieldOptions)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InputMutation) ClearField(name string) error {
	switch name {
	case input.FieldMultiple:
		m.ClearMultiple()
		return nil
	case input.FieldDefaults:
		m.ClearDefaults()
		return nil
	case input.FieldOptions:
		m.ClearOptions()
		return nil
	}
	return fmt.Errorf("unknown Input nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InputMutation) ResetField(name string) error {
	switch name {
	case input.FieldKind:
		m.ResetKind()
		return nil
	case input.FieldMultiple:
		m.ResetMultiple()
		return nil
	case input.FieldDefaults:
		m.ResetDefaults()
		return nil
	case input.FieldOptions:
		m.ResetOptions()
		return nil
	}
	return fmt.Errorf("unknown Input field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InputMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question != nil {
		edges = append(edges, input.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case input.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InputMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion {
		edges = append(edges, input.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InputMutation) EdgeCleared(name string) bool {
	switch name {
	case input.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InputMutation) ClearEdge(name string) error {
	switch name {
	case input.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown Input unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InputMutation) ResetEdge(name string) error {
	switch name {
	case input.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown Input edge %s", name)
}

// PersonMutation represents an operation that mutate the Persons
// nodes in the graph.
type PersonMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	lastActivity    *time.Time
	username        *string
	picture         *string
	roles           *[]string
	clearedFields   map[string]struct{}
	accounts        map[uuid.UUID]struct{}
	removedaccounts map[uuid.UUID]struct{}
	contacts        map[uuid.UUID]struct{}
	removedcontacts map[uuid.UUID]struct{}
	surveys         map[uuid.UUID]struct{}
	removedsurveys  map[uuid.UUID]struct{}
	domains         map[uuid.UUID]struct{}
	removeddomains  map[uuid.UUID]struct{}
	adminOf         map[uuid.UUID]struct{}
	removedadminOf  map[uuid.UUID]struct{}
}

var _ ent.Mutation = (*PersonMutation)(nil)

// newPersonMutation creates new mutation for $n.Name.
func newPersonMutation(c config, op Op) *PersonMutation {
	return &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Person creation.
func (m *PersonMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PersonMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetLastActivity sets the lastActivity field.
func (m *PersonMutation) SetLastActivity(t time.Time) {
	m.lastActivity = &t
}

// LastActivity returns the lastActivity value in the mutation.
func (m *PersonMutation) LastActivity() (r time.Time, exists bool) {
	v := m.lastActivity
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastActivity reset all changes of the lastActivity field.
func (m *PersonMutation) ResetLastActivity() {
	m.lastActivity = nil
}

// SetUsername sets the username field.
func (m *PersonMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *PersonMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsername clears the value of username.
func (m *PersonMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[person.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the field username was cleared in this mutation.
func (m *PersonMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[person.FieldUsername]
	return ok
}

// ResetUsername reset all changes of the username field.
func (m *PersonMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, person.FieldUsername)
}

// SetPicture sets the picture field.
func (m *PersonMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the picture value in the mutation.
func (m *PersonMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// ClearPicture clears the value of picture.
func (m *PersonMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[person.FieldPicture] = struct{}{}
}

// PictureCleared returns if the field picture was cleared in this mutation.
func (m *PersonMutation) PictureCleared() bool {
	_, ok := m.clearedFields[person.FieldPicture]
	return ok
}

// ResetPicture reset all changes of the picture field.
func (m *PersonMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, person.FieldPicture)
}

// SetRoles sets the roles field.
func (m *PersonMutation) SetRoles(s []string) {
	m.roles = &s
}

// Roles returns the roles value in the mutation.
func (m *PersonMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoles clears the value of roles.
func (m *PersonMutation) ClearRoles() {
	m.roles = nil
	m.clearedFields[person.FieldRoles] = struct{}{}
}

// RolesCleared returns if the field roles was cleared in this mutation.
func (m *PersonMutation) RolesCleared() bool {
	_, ok := m.clearedFields[person.FieldRoles]
	return ok
}

// ResetRoles reset all changes of the roles field.
func (m *PersonMutation) ResetRoles() {
	m.roles = nil
	delete(m.clearedFields, person.FieldRoles)
}

// AddAccountIDs adds the accounts edge to Account by ids.
func (m *PersonMutation) AddAccountIDs(ids ...uuid.UUID) {
	if m.accounts == nil {
		m.accounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// RemoveAccountIDs removes the accounts edge to Account by ids.
func (m *PersonMutation) RemoveAccountIDs(ids ...uuid.UUID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed ids of accounts.
func (m *PersonMutation) RemovedAccountsIDs() (ids []uuid.UUID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the accounts ids in the mutation.
func (m *PersonMutation) AccountsIDs() (ids []uuid.UUID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts reset all changes of the accounts edge.
func (m *PersonMutation) ResetAccounts() {
	m.accounts = nil
	m.removedaccounts = nil
}

// AddContactIDs adds the contacts edge to Contact by ids.
func (m *PersonMutation) AddContactIDs(ids ...uuid.UUID) {
	if m.contacts == nil {
		m.contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// RemoveContactIDs removes the contacts edge to Contact by ids.
func (m *PersonMutation) RemoveContactIDs(ids ...uuid.UUID) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed ids of contacts.
func (m *PersonMutation) RemovedContactsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the contacts ids in the mutation.
func (m *PersonMutation) ContactsIDs() (ids []uuid.UUID) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts reset all changes of the contacts edge.
func (m *PersonMutation) ResetContacts() {
	m.contacts = nil
	m.removedcontacts = nil
}

// AddSurveyIDs adds the surveys edge to Survey by ids.
func (m *PersonMutation) AddSurveyIDs(ids ...uuid.UUID) {
	if m.surveys == nil {
		m.surveys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.surveys[ids[i]] = struct{}{}
	}
}

// RemoveSurveyIDs removes the surveys edge to Survey by ids.
func (m *PersonMutation) RemoveSurveyIDs(ids ...uuid.UUID) {
	if m.removedsurveys == nil {
		m.removedsurveys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedsurveys[ids[i]] = struct{}{}
	}
}

// RemovedSurveys returns the removed ids of surveys.
func (m *PersonMutation) RemovedSurveysIDs() (ids []uuid.UUID) {
	for id := range m.removedsurveys {
		ids = append(ids, id)
	}
	return
}

// SurveysIDs returns the surveys ids in the mutation.
func (m *PersonMutation) SurveysIDs() (ids []uuid.UUID) {
	for id := range m.surveys {
		ids = append(ids, id)
	}
	return
}

// ResetSurveys reset all changes of the surveys edge.
func (m *PersonMutation) ResetSurveys() {
	m.surveys = nil
	m.removedsurveys = nil
}

// AddDomainIDs adds the domains edge to Domain by ids.
func (m *PersonMutation) AddDomainIDs(ids ...uuid.UUID) {
	if m.domains == nil {
		m.domains = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.domains[ids[i]] = struct{}{}
	}
}

// RemoveDomainIDs removes the domains edge to Domain by ids.
func (m *PersonMutation) RemoveDomainIDs(ids ...uuid.UUID) {
	if m.removeddomains == nil {
		m.removeddomains = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removeddomains[ids[i]] = struct{}{}
	}
}

// RemovedDomains returns the removed ids of domains.
func (m *PersonMutation) RemovedDomainsIDs() (ids []uuid.UUID) {
	for id := range m.removeddomains {
		ids = append(ids, id)
	}
	return
}

// DomainsIDs returns the domains ids in the mutation.
func (m *PersonMutation) DomainsIDs() (ids []uuid.UUID) {
	for id := range m.domains {
		ids = append(ids, id)
	}
	return
}

// ResetDomains reset all changes of the domains edge.
func (m *PersonMutation) ResetDomains() {
	m.domains = nil
	m.removeddomains = nil
}

// AddAdminOfIDs adds the adminOf edge to Domain by ids.
func (m *PersonMutation) AddAdminOfIDs(ids ...uuid.UUID) {
	if m.adminOf == nil {
		m.adminOf = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.adminOf[ids[i]] = struct{}{}
	}
}

// RemoveAdminOfIDs removes the adminOf edge to Domain by ids.
func (m *PersonMutation) RemoveAdminOfIDs(ids ...uuid.UUID) {
	if m.removedadminOf == nil {
		m.removedadminOf = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedadminOf[ids[i]] = struct{}{}
	}
}

// RemovedAdminOf returns the removed ids of adminOf.
func (m *PersonMutation) RemovedAdminOfIDs() (ids []uuid.UUID) {
	for id := range m.removedadminOf {
		ids = append(ids, id)
	}
	return
}

// AdminOfIDs returns the adminOf ids in the mutation.
func (m *PersonMutation) AdminOfIDs() (ids []uuid.UUID) {
	for id := range m.adminOf {
		ids = append(ids, id)
	}
	return
}

// ResetAdminOf reset all changes of the adminOf edge.
func (m *PersonMutation) ResetAdminOf() {
	m.adminOf = nil
	m.removedadminOf = nil
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.lastActivity != nil {
		fields = append(fields, person.FieldLastActivity)
	}
	if m.username != nil {
		fields = append(fields, person.FieldUsername)
	}
	if m.picture != nil {
		fields = append(fields, person.FieldPicture)
	}
	if m.roles != nil {
		fields = append(fields, person.FieldRoles)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldName:
		return m.Name()
	case person.FieldLastActivity:
		return m.LastActivity()
	case person.FieldUsername:
		return m.Username()
	case person.FieldPicture:
		return m.Picture()
	case person.FieldRoles:
		return m.Roles()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldLastActivity:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActivity(v)
		return nil
	case person.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case person.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case person.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldUsername) {
		fields = append(fields, person.FieldUsername)
	}
	if m.FieldCleared(person.FieldPicture) {
		fields = append(fields, person.FieldPicture)
	}
	if m.FieldCleared(person.FieldRoles) {
		fields = append(fields, person.FieldRoles)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldUsername:
		m.ClearUsername()
		return nil
	case person.FieldPicture:
		m.ClearPicture()
		return nil
	case person.FieldRoles:
		m.ClearRoles()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldLastActivity:
		m.ResetLastActivity()
		return nil
	case person.FieldUsername:
		m.ResetUsername()
		return nil
	case person.FieldPicture:
		m.ResetPicture()
		return nil
	case person.FieldRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.accounts != nil {
		edges = append(edges, person.EdgeAccounts)
	}
	if m.contacts != nil {
		edges = append(edges, person.EdgeContacts)
	}
	if m.surveys != nil {
		edges = append(edges, person.EdgeSurveys)
	}
	if m.domains != nil {
		edges = append(edges, person.EdgeDomains)
	}
	if m.adminOf != nil {
		edges = append(edges, person.EdgeAdminOf)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.surveys))
		for id := range m.surveys {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeDomains:
		ids := make([]ent.Value, 0, len(m.domains))
		for id := range m.domains {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeAdminOf:
		ids := make([]ent.Value, 0, len(m.adminOf))
		for id := range m.adminOf {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedaccounts != nil {
		edges = append(edges, person.EdgeAccounts)
	}
	if m.removedcontacts != nil {
		edges = append(edges, person.EdgeContacts)
	}
	if m.removedsurveys != nil {
		edges = append(edges, person.EdgeSurveys)
	}
	if m.removeddomains != nil {
		edges = append(edges, person.EdgeDomains)
	}
	if m.removedadminOf != nil {
		edges = append(edges, person.EdgeAdminOf)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.removedsurveys))
		for id := range m.removedsurveys {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeDomains:
		ids := make([]ent.Value, 0, len(m.removeddomains))
		for id := range m.removeddomains {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeAdminOf:
		ids := make([]ent.Value, 0, len(m.removedadminOf))
		for id := range m.removedadminOf {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case person.EdgeContacts:
		m.ResetContacts()
		return nil
	case person.EdgeSurveys:
		m.ResetSurveys()
		return nil
	case person.EdgeDomains:
		m.ResetDomains()
		return nil
	case person.EdgeAdminOf:
		m.ResetAdminOf()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// QuestionMutation represents an operation that mutate the Questions
// nodes in the graph.
type QuestionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	hash           *string
	title          *string
	description    *string
	metadata       *map[string]string
	validator      *string
	anonymous      *bool
	clearedFields  map[string]struct{}
	answers        map[uuid.UUID]struct{}
	removedanswers map[uuid.UUID]struct{}
	input          *uuid.UUID
	clearedinput   bool
	flow           *uuid.UUID
	clearedflow    bool
}

var _ ent.Mutation = (*QuestionMutation)(nil)

// newQuestionMutation creates new mutation for $n.Name.
func newQuestionMutation(c config, op Op) *QuestionMutation {
	return &QuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestion,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Question creation.
func (m *QuestionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *QuestionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHash sets the hash field.
func (m *QuestionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the hash value in the mutation.
func (m *QuestionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// ResetHash reset all changes of the hash field.
func (m *QuestionMutation) ResetHash() {
	m.hash = nil
}

// SetTitle sets the title field.
func (m *QuestionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *QuestionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// ResetTitle reset all changes of the title field.
func (m *QuestionMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the description field.
func (m *QuestionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *QuestionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// ResetDescription reset all changes of the description field.
func (m *QuestionMutation) ResetDescription() {
	m.description = nil
}

// SetMetadata sets the metadata field.
func (m *QuestionMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the metadata value in the mutation.
func (m *QuestionMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetadata clears the value of metadata.
func (m *QuestionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[question.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the field metadata was cleared in this mutation.
func (m *QuestionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[question.FieldMetadata]
	return ok
}

// ResetMetadata reset all changes of the metadata field.
func (m *QuestionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, question.FieldMetadata)
}

// SetValidator sets the validator field.
func (m *QuestionMutation) SetValidator(s string) {
	m.validator = &s
}

// Validator returns the validator value in the mutation.
func (m *QuestionMutation) Validator() (r string, exists bool) {
	v := m.validator
	if v == nil {
		return
	}
	return *v, true
}

// ClearValidator clears the value of validator.
func (m *QuestionMutation) ClearValidator() {
	m.validator = nil
	m.clearedFields[question.FieldValidator] = struct{}{}
}

// ValidatorCleared returns if the field validator was cleared in this mutation.
func (m *QuestionMutation) ValidatorCleared() bool {
	_, ok := m.clearedFields[question.FieldValidator]
	return ok
}

// ResetValidator reset all changes of the validator field.
func (m *QuestionMutation) ResetValidator() {
	m.validator = nil
	delete(m.clearedFields, question.FieldValidator)
}

// SetAnonymous sets the anonymous field.
func (m *QuestionMutation) SetAnonymous(b bool) {
	m.anonymous = &b
}

// Anonymous returns the anonymous value in the mutation.
func (m *QuestionMutation) Anonymous() (r bool, exists bool) {
	v := m.anonymous
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnonymous reset all changes of the anonymous field.
func (m *QuestionMutation) ResetAnonymous() {
	m.anonymous = nil
}

// AddAnswerIDs adds the answers edge to Answer by ids.
func (m *QuestionMutation) AddAnswerIDs(ids ...uuid.UUID) {
	if m.answers == nil {
		m.answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.answers[ids[i]] = struct{}{}
	}
}

// RemoveAnswerIDs removes the answers edge to Answer by ids.
func (m *QuestionMutation) RemoveAnswerIDs(ids ...uuid.UUID) {
	if m.removedanswers == nil {
		m.removedanswers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedanswers[ids[i]] = struct{}{}
	}
}

// RemovedAnswers returns the removed ids of answers.
func (m *QuestionMutation) RemovedAnswersIDs() (ids []uuid.UUID) {
	for id := range m.removedanswers {
		ids = append(ids, id)
	}
	return
}

// AnswersIDs returns the answers ids in the mutation.
func (m *QuestionMutation) AnswersIDs() (ids []uuid.UUID) {
	for id := range m.answers {
		ids = append(ids, id)
	}
	return
}

// ResetAnswers reset all changes of the answers edge.
func (m *QuestionMutation) ResetAnswers() {
	m.answers = nil
	m.removedanswers = nil
}

// SetInputID sets the input edge to Input by id.
func (m *QuestionMutation) SetInputID(id uuid.UUID) {
	m.input = &id
}

// ClearInput clears the input edge to Input.
func (m *QuestionMutation) ClearInput() {
	m.clearedinput = true
}

// InputCleared returns if the edge input was cleared.
func (m *QuestionMutation) InputCleared() bool {
	return m.clearedinput
}

// InputID returns the input id in the mutation.
func (m *QuestionMutation) InputID() (id uuid.UUID, exists bool) {
	if m.input != nil {
		return *m.input, true
	}
	return
}

// InputIDs returns the input ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InputID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) InputIDs() (ids []uuid.UUID) {
	if id := m.input; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInput reset all changes of the input edge.
func (m *QuestionMutation) ResetInput() {
	m.input = nil
	m.clearedinput = false
}

// SetFlowID sets the flow edge to Flow by id.
func (m *QuestionMutation) SetFlowID(id uuid.UUID) {
	m.flow = &id
}

// ClearFlow clears the flow edge to Flow.
func (m *QuestionMutation) ClearFlow() {
	m.clearedflow = true
}

// FlowCleared returns if the edge flow was cleared.
func (m *QuestionMutation) FlowCleared() bool {
	return m.clearedflow
}

// FlowID returns the flow id in the mutation.
func (m *QuestionMutation) FlowID() (id uuid.UUID, exists bool) {
	if m.flow != nil {
		return *m.flow, true
	}
	return
}

// FlowIDs returns the flow ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) FlowIDs() (ids []uuid.UUID) {
	if id := m.flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlow reset all changes of the flow edge.
func (m *QuestionMutation) ResetFlow() {
	m.flow = nil
	m.clearedflow = false
}

// Op returns the operation name.
func (m *QuestionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Question).
func (m *QuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *QuestionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hash != nil {
		fields = append(fields, question.FieldHash)
	}
	if m.title != nil {
		fields = append(fields, question.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, question.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, question.FieldMetadata)
	}
	if m.validator != nil {
		fields = append(fields, question.FieldValidator)
	}
	if m.anonymous != nil {
		fields = append(fields, question.FieldAnonymous)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *QuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case question.FieldHash:
		return m.Hash()
	case question.FieldTitle:
		return m.Title()
	case question.FieldDescription:
		return m.Description()
	case question.FieldMetadata:
		return m.Metadata()
	case question.FieldValidator:
		return m.Validator()
	case question.FieldAnonymous:
		return m.Anonymous()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case question.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case question.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case question.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case question.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case question.FieldValidator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidator(v)
		return nil
	case question.FieldAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnonymous(v)
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *QuestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *QuestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Question numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *QuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(question.FieldMetadata) {
		fields = append(fields, question.FieldMetadata)
	}
	if m.FieldCleared(question.FieldValidator) {
		fields = append(fields, question.FieldValidator)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *QuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionMutation) ClearField(name string) error {
	switch name {
	case question.FieldMetadata:
		m.ClearMetadata()
		return nil
	case question.FieldValidator:
		m.ClearValidator()
		return nil
	}
	return fmt.Errorf("unknown Question nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *QuestionMutation) ResetField(name string) error {
	switch name {
	case question.FieldHash:
		m.ResetHash()
		return nil
	case question.FieldTitle:
		m.ResetTitle()
		return nil
	case question.FieldDescription:
		m.ResetDescription()
		return nil
	case question.FieldMetadata:
		m.ResetMetadata()
		return nil
	case question.FieldValidator:
		m.ResetValidator()
		return nil
	case question.FieldAnonymous:
		m.ResetAnonymous()
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *QuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.answers != nil {
		edges = append(edges, question.EdgeAnswers)
	}
	if m.input != nil {
		edges = append(edges, question.EdgeInput)
	}
	if m.flow != nil {
		edges = append(edges, question.EdgeFlow)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *QuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeAnswers:
		ids := make([]ent.Value, 0, len(m.answers))
		for id := range m.answers {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeInput:
		if id := m.input; id != nil {
			return []ent.Value{*id}
		}
	case question.EdgeFlow:
		if id := m.flow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *QuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedanswers != nil {
		edges = append(edges, question.EdgeAnswers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *QuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeAnswers:
		ids := make([]ent.Value, 0, len(m.removedanswers))
		for id := range m.removedanswers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *QuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedinput {
		edges = append(edges, question.EdgeInput)
	}
	if m.clearedflow {
		edges = append(edges, question.EdgeFlow)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *QuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case question.EdgeInput:
		return m.clearedinput
	case question.EdgeFlow:
		return m.clearedflow
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *QuestionMutation) ClearEdge(name string) error {
	switch name {
	case question.EdgeInput:
		m.ClearInput()
		return nil
	case question.EdgeFlow:
		m.ClearFlow()
		return nil
	}
	return fmt.Errorf("unknown Question unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *QuestionMutation) ResetEdge(name string) error {
	switch name {
	case question.EdgeAnswers:
		m.ResetAnswers()
		return nil
	case question.EdgeInput:
		m.ResetInput()
		return nil
	case question.EdgeFlow:
		m.ResetFlow()
		return nil
	}
	return fmt.Errorf("unknown Question edge %s", name)
}

// ShortMutation represents an operation that mutate the Shorts
// nodes in the graph.
type ShortMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *uuid.UUID
	clearedFields map[string]struct{}
}

var _ ent.Mutation = (*ShortMutation)(nil)

// newShortMutation creates new mutation for $n.Name.
func newShortMutation(c config, op Op) *ShortMutation {
	return &ShortMutation{
		config:        c,
		op:            op,
		typ:           TypeShort,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShortMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShortMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShortMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetKey sets the key field.
func (m *ShortMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the key value in the mutation.
func (m *ShortMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// ResetKey reset all changes of the key field.
func (m *ShortMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the value field.
func (m *ShortMutation) SetValue(u uuid.UUID) {
	m.value = &u
}

// Value returns the value value in the mutation.
func (m *ShortMutation) Value() (r uuid.UUID, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue reset all changes of the value field.
func (m *ShortMutation) ResetValue() {
	m.value = nil
}

// Op returns the operation name.
func (m *ShortMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Short).
func (m *ShortMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShortMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.key != nil {
		fields = append(fields, short.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, short.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShortMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case short.FieldKey:
		return m.Key()
	case short.FieldValue:
		return m.Value()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShortMutation) SetField(name string, value ent.Value) error {
	switch name {
	case short.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case short.FieldValue:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Short field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShortMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShortMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShortMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Short numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShortMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShortMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShortMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Short nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShortMutation) ResetField(name string) error {
	switch name {
	case short.FieldKey:
		m.ResetKey()
		return nil
	case short.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Short field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShortMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShortMutation) AddedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShortMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShortMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShortMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShortMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShortMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Short unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShortMutation) ResetEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Short edge %s", name)
}

// SurveyMutation represents an operation that mutate the Surveys
// nodes in the graph.
type SurveyMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	tags            *[]string
	lastInteraction *time.Time
	dueDate         *time.Time
	title           *string
	description     *string
	metadata        *map[string]string
	done            *bool
	isPublic        *bool
	clearedFields   map[string]struct{}
	flow            *uuid.UUID
	clearedflow     bool
	_for            *uuid.UUID
	cleared_for     bool
	owner           *uuid.UUID
	clearedowner    bool
}

var _ ent.Mutation = (*SurveyMutation)(nil)

// newSurveyMutation creates new mutation for $n.Name.
func newSurveyMutation(c config, op Op) *SurveyMutation {
	return &SurveyMutation{
		config:        c,
		op:            op,
		typ:           TypeSurvey,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Survey creation.
func (m *SurveyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SurveyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTags sets the tags field.
func (m *SurveyMutation) SetTags(s []string) {
	m.tags = &s
}

// Tags returns the tags value in the mutation.
func (m *SurveyMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// ResetTags reset all changes of the tags field.
func (m *SurveyMutation) ResetTags() {
	m.tags = nil
}

// SetLastInteraction sets the lastInteraction field.
func (m *SurveyMutation) SetLastInteraction(t time.Time) {
	m.lastInteraction = &t
}

// LastInteraction returns the lastInteraction value in the mutation.
func (m *SurveyMutation) LastInteraction() (r time.Time, exists bool) {
	v := m.lastInteraction
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastInteraction reset all changes of the lastInteraction field.
func (m *SurveyMutation) ResetLastInteraction() {
	m.lastInteraction = nil
}

// SetDueDate sets the dueDate field.
func (m *SurveyMutation) SetDueDate(t time.Time) {
	m.dueDate = &t
}

// DueDate returns the dueDate value in the mutation.
func (m *SurveyMutation) DueDate() (r time.Time, exists bool) {
	v := m.dueDate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDueDate reset all changes of the dueDate field.
func (m *SurveyMutation) ResetDueDate() {
	m.dueDate = nil
}

// SetTitle sets the title field.
func (m *SurveyMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *SurveyMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// ResetTitle reset all changes of the title field.
func (m *SurveyMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the description field.
func (m *SurveyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *SurveyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// ClearDescription clears the value of description.
func (m *SurveyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[survey.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *SurveyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[survey.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the description field.
func (m *SurveyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, survey.FieldDescription)
}

// SetMetadata sets the metadata field.
func (m *SurveyMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the metadata value in the mutation.
func (m *SurveyMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetadata clears the value of metadata.
func (m *SurveyMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[survey.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the field metadata was cleared in this mutation.
func (m *SurveyMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[survey.FieldMetadata]
	return ok
}

// ResetMetadata reset all changes of the metadata field.
func (m *SurveyMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, survey.FieldMetadata)
}

// SetDone sets the done field.
func (m *SurveyMutation) SetDone(b bool) {
	m.done = &b
}

// Done returns the done value in the mutation.
func (m *SurveyMutation) Done() (r bool, exists bool) {
	v := m.done
	if v == nil {
		return
	}
	return *v, true
}

// ClearDone clears the value of done.
func (m *SurveyMutation) ClearDone() {
	m.done = nil
	m.clearedFields[survey.FieldDone] = struct{}{}
}

// DoneCleared returns if the field done was cleared in this mutation.
func (m *SurveyMutation) DoneCleared() bool {
	_, ok := m.clearedFields[survey.FieldDone]
	return ok
}

// ResetDone reset all changes of the done field.
func (m *SurveyMutation) ResetDone() {
	m.done = nil
	delete(m.clearedFields, survey.FieldDone)
}

// SetIsPublic sets the isPublic field.
func (m *SurveyMutation) SetIsPublic(b bool) {
	m.isPublic = &b
}

// IsPublic returns the isPublic value in the mutation.
func (m *SurveyMutation) IsPublic() (r bool, exists bool) {
	v := m.isPublic
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsPublic clears the value of isPublic.
func (m *SurveyMutation) ClearIsPublic() {
	m.isPublic = nil
	m.clearedFields[survey.FieldIsPublic] = struct{}{}
}

// IsPublicCleared returns if the field isPublic was cleared in this mutation.
func (m *SurveyMutation) IsPublicCleared() bool {
	_, ok := m.clearedFields[survey.FieldIsPublic]
	return ok
}

// ResetIsPublic reset all changes of the isPublic field.
func (m *SurveyMutation) ResetIsPublic() {
	m.isPublic = nil
	delete(m.clearedFields, survey.FieldIsPublic)
}

// SetFlowID sets the flow edge to Flow by id.
func (m *SurveyMutation) SetFlowID(id uuid.UUID) {
	m.flow = &id
}

// ClearFlow clears the flow edge to Flow.
func (m *SurveyMutation) ClearFlow() {
	m.clearedflow = true
}

// FlowCleared returns if the edge flow was cleared.
func (m *SurveyMutation) FlowCleared() bool {
	return m.clearedflow
}

// FlowID returns the flow id in the mutation.
func (m *SurveyMutation) FlowID() (id uuid.UUID, exists bool) {
	if m.flow != nil {
		return *m.flow, true
	}
	return
}

// FlowIDs returns the flow ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowID instead. It exists only for internal usage by the builders.
func (m *SurveyMutation) FlowIDs() (ids []uuid.UUID) {
	if id := m.flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlow reset all changes of the flow edge.
func (m *SurveyMutation) ResetFlow() {
	m.flow = nil
	m.clearedflow = false
}

// SetForID sets the for edge to Person by id.
func (m *SurveyMutation) SetForID(id uuid.UUID) {
	m._for = &id
}

// ClearFor clears the for edge to Person.
func (m *SurveyMutation) ClearFor() {
	m.cleared_for = true
}

// ForCleared returns if the edge for was cleared.
func (m *SurveyMutation) ForCleared() bool {
	return m.cleared_for
}

// ForID returns the for id in the mutation.
func (m *SurveyMutation) ForID() (id uuid.UUID, exists bool) {
	if m._for != nil {
		return *m._for, true
	}
	return
}

// ForIDs returns the for ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ForID instead. It exists only for internal usage by the builders.
func (m *SurveyMutation) ForIDs() (ids []uuid.UUID) {
	if id := m._for; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFor reset all changes of the for edge.
func (m *SurveyMutation) ResetFor() {
	m._for = nil
	m.cleared_for = false
}

// SetOwnerID sets the owner edge to Domain by id.
func (m *SurveyMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Domain.
func (m *SurveyMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *SurveyMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *SurveyMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SurveyMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the owner edge.
func (m *SurveyMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *SurveyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Survey).
func (m *SurveyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SurveyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tags != nil {
		fields = append(fields, survey.FieldTags)
	}
	if m.lastInteraction != nil {
		fields = append(fields, survey.FieldLastInteraction)
	}
	if m.dueDate != nil {
		fields = append(fields, survey.FieldDueDate)
	}
	if m.title != nil {
		fields = append(fields, survey.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, survey.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, survey.FieldMetadata)
	}
	if m.done != nil {
		fields = append(fields, survey.FieldDone)
	}
	if m.isPublic != nil {
		fields = append(fields, survey.FieldIsPublic)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SurveyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldTags:
		return m.Tags()
	case survey.FieldLastInteraction:
		return m.LastInteraction()
	case survey.FieldDueDate:
		return m.DueDate()
	case survey.FieldTitle:
		return m.Title()
	case survey.FieldDescription:
		return m.Description()
	case survey.FieldMetadata:
		return m.Metadata()
	case survey.FieldDone:
		return m.Done()
	case survey.FieldIsPublic:
		return m.IsPublic()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case survey.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case survey.FieldLastInteraction:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInteraction(v)
		return nil
	case survey.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case survey.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case survey.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case survey.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case survey.FieldDone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDone(v)
		return nil
	case survey.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SurveyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SurveyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Survey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SurveyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(survey.FieldDescription) {
		fields = append(fields, survey.FieldDescription)
	}
	if m.FieldCleared(survey.FieldMetadata) {
		fields = append(fields, survey.FieldMetadata)
	}
	if m.FieldCleared(survey.FieldDone) {
		fields = append(fields, survey.FieldDone)
	}
	if m.FieldCleared(survey.FieldIsPublic) {
		fields = append(fields, survey.FieldIsPublic)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SurveyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyMutation) ClearField(name string) error {
	switch name {
	case survey.FieldDescription:
		m.ClearDescription()
		return nil
	case survey.FieldMetadata:
		m.ClearMetadata()
		return nil
	case survey.FieldDone:
		m.ClearDone()
		return nil
	case survey.FieldIsPublic:
		m.ClearIsPublic()
		return nil
	}
	return fmt.Errorf("unknown Survey nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SurveyMutation) ResetField(name string) error {
	switch name {
	case survey.FieldTags:
		m.ResetTags()
		return nil
	case survey.FieldLastInteraction:
		m.ResetLastInteraction()
		return nil
	case survey.FieldDueDate:
		m.ResetDueDate()
		return nil
	case survey.FieldTitle:
		m.ResetTitle()
		return nil
	case survey.FieldDescription:
		m.ResetDescription()
		return nil
	case survey.FieldMetadata:
		m.ResetMetadata()
		return nil
	case survey.FieldDone:
		m.ResetDone()
		return nil
	case survey.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SurveyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.flow != nil {
		edges = append(edges, survey.EdgeFlow)
	}
	if m._for != nil {
		edges = append(edges, survey.EdgeFor)
	}
	if m.owner != nil {
		edges = append(edges, survey.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SurveyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeFlow:
		if id := m.flow; id != nil {
			return []ent.Value{*id}
		}
	case survey.EdgeFor:
		if id := m._for; id != nil {
			return []ent.Value{*id}
		}
	case survey.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SurveyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SurveyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SurveyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedflow {
		edges = append(edges, survey.EdgeFlow)
	}
	if m.cleared_for {
		edges = append(edges, survey.EdgeFor)
	}
	if m.clearedowner {
		edges = append(edges, survey.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SurveyMutation) EdgeCleared(name string) bool {
	switch name {
	case survey.EdgeFlow:
		return m.clearedflow
	case survey.EdgeFor:
		return m.cleared_for
	case survey.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SurveyMutation) ClearEdge(name string) error {
	switch name {
	case survey.EdgeFlow:
		m.ClearFlow()
		return nil
	case survey.EdgeFor:
		m.ClearFor()
		return nil
	case survey.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Survey unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SurveyMutation) ResetEdge(name string) error {
	switch name {
	case survey.EdgeFlow:
		m.ResetFlow()
		return nil
	case survey.EdgeFor:
		m.ResetFor()
		return nil
	case survey.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Survey edge %s", name)
}
