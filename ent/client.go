// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/minskylab/collecta/ent/migrate"
	"github.com/rs/xid"

	"github.com/minskylab/collecta/ent/account"
	"github.com/minskylab/collecta/ent/answer"
	"github.com/minskylab/collecta/ent/contact"
	"github.com/minskylab/collecta/ent/device"
	"github.com/minskylab/collecta/ent/domain"
	"github.com/minskylab/collecta/ent/flow"
	"github.com/minskylab/collecta/ent/input"
	"github.com/minskylab/collecta/ent/ip"
	"github.com/minskylab/collecta/ent/question"
	"github.com/minskylab/collecta/ent/survey"
	"github.com/minskylab/collecta/ent/user"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// Answer is the client for interacting with the Answer builders.
	Answer *AnswerClient
	// Contact is the client for interacting with the Contact builders.
	Contact *ContactClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// Domain is the client for interacting with the Domain builders.
	Domain *DomainClient
	// Flow is the client for interacting with the Flow builders.
	Flow *FlowClient
	// IP is the client for interacting with the IP builders.
	IP *IPClient
	// Input is the client for interacting with the Input builders.
	Input *InputClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// Survey is the client for interacting with the Survey builders.
	Survey *SurveyClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	c := config{log: log.Println}
	c.options(opts...)
	return &Client{
		config:   c,
		Schema:   migrate.NewSchema(c.driver),
		Account:  NewAccountClient(c),
		Answer:   NewAnswerClient(c),
		Contact:  NewContactClient(c),
		Device:   NewDeviceClient(c),
		Domain:   NewDomainClient(c),
		Flow:     NewFlowClient(c),
		IP:       NewIPClient(c),
		Input:    NewInputClient(c),
		Question: NewQuestionClient(c),
		Survey:   NewSurveyClient(c),
		User:     NewUserClient(c),
	}
}

// Open opens a connection to the database specified by the driver name and a
// driver-specific data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug}
	return &Tx{
		config:   cfg,
		Account:  NewAccountClient(cfg),
		Answer:   NewAnswerClient(cfg),
		Contact:  NewContactClient(cfg),
		Device:   NewDeviceClient(cfg),
		Domain:   NewDomainClient(cfg),
		Flow:     NewFlowClient(cfg),
		IP:       NewIPClient(cfg),
		Input:    NewInputClient(cfg),
		Question: NewQuestionClient(cfg),
		Survey:   NewSurveyClient(cfg),
		User:     NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true}
	return &Client{
		config:   cfg,
		Schema:   migrate.NewSchema(cfg.driver),
		Account:  NewAccountClient(cfg),
		Answer:   NewAnswerClient(cfg),
		Contact:  NewContactClient(cfg),
		Device:   NewDeviceClient(cfg),
		Domain:   NewDomainClient(cfg),
		Flow:     NewFlowClient(cfg),
		IP:       NewIPClient(cfg),
		Input:    NewInputClient(cfg),
		Question: NewQuestionClient(cfg),
		Survey:   NewSurveyClient(cfg),
		User:     NewUserClient(cfg),
	}
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Create returns a create builder for Account.
func (c *AccountClient) Create() *AccountCreate {
	return &AccountCreate{config: c.config}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	return &AccountUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(a *Account) *AccountUpdateOne {
	return c.UpdateOneID(a.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id uuid.UUID) *AccountUpdateOne {
	return &AccountUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	return &AccountDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AccountClient) DeleteOne(a *Account) *AccountDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AccountClient) DeleteOneID(id uuid.UUID) *AccountDeleteOne {
	return &AccountDeleteOne{c.Delete().Where(account.ID(id))}
}

// Create returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{config: c.config}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id uuid.UUID) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id uuid.UUID) *Account {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryOwner queries the owner edge of a Account.
func (c *AccountClient) QueryOwner(a *Account) *UserQuery {
	query := &UserQuery{config: c.config}
	id := a.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(account.Table, account.FieldID, id),
		sqlgraph.To(user.Table, user.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, account.OwnerTable, account.OwnerColumn),
	)
	query.sql = sqlgraph.Neighbors(a.driver.Dialect(), step)

	return query
}

// AnswerClient is a client for the Answer schema.
type AnswerClient struct {
	config
}

// NewAnswerClient returns a client for the Answer from the given config.
func NewAnswerClient(c config) *AnswerClient {
	return &AnswerClient{config: c}
}

// Create returns a create builder for Answer.
func (c *AnswerClient) Create() *AnswerCreate {
	return &AnswerCreate{config: c.config}
}

// Update returns an update builder for Answer.
func (c *AnswerClient) Update() *AnswerUpdate {
	return &AnswerUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnswerClient) UpdateOne(a *Answer) *AnswerUpdateOne {
	return c.UpdateOneID(a.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *AnswerClient) UpdateOneID(id xid.ID) *AnswerUpdateOne {
	return &AnswerUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Answer.
func (c *AnswerClient) Delete() *AnswerDelete {
	return &AnswerDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AnswerClient) DeleteOne(a *Answer) *AnswerDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AnswerClient) DeleteOneID(id xid.ID) *AnswerDeleteOne {
	return &AnswerDeleteOne{c.Delete().Where(answer.ID(id))}
}

// Create returns a query builder for Answer.
func (c *AnswerClient) Query() *AnswerQuery {
	return &AnswerQuery{config: c.config}
}

// Get returns a Answer entity by its id.
func (c *AnswerClient) Get(ctx context.Context, id xid.ID) (*Answer, error) {
	return c.Query().Where(answer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnswerClient) GetX(ctx context.Context, id xid.ID) *Answer {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryQuestion queries the question edge of a Answer.
func (c *AnswerClient) QueryQuestion(a *Answer) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	id := a.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(answer.Table, answer.FieldID, id),
		sqlgraph.To(question.Table, question.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, answer.QuestionTable, answer.QuestionColumn),
	)
	query.sql = sqlgraph.Neighbors(a.driver.Dialect(), step)

	return query
}

// ContactClient is a client for the Contact schema.
type ContactClient struct {
	config
}

// NewContactClient returns a client for the Contact from the given config.
func NewContactClient(c config) *ContactClient {
	return &ContactClient{config: c}
}

// Create returns a create builder for Contact.
func (c *ContactClient) Create() *ContactCreate {
	return &ContactCreate{config: c.config}
}

// Update returns an update builder for Contact.
func (c *ContactClient) Update() *ContactUpdate {
	return &ContactUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactClient) UpdateOne(co *Contact) *ContactUpdateOne {
	return c.UpdateOneID(co.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactClient) UpdateOneID(id uuid.UUID) *ContactUpdateOne {
	return &ContactUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Contact.
func (c *ContactClient) Delete() *ContactDelete {
	return &ContactDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ContactClient) DeleteOne(co *Contact) *ContactDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ContactClient) DeleteOneID(id uuid.UUID) *ContactDeleteOne {
	return &ContactDeleteOne{c.Delete().Where(contact.ID(id))}
}

// Create returns a query builder for Contact.
func (c *ContactClient) Query() *ContactQuery {
	return &ContactQuery{config: c.config}
}

// Get returns a Contact entity by its id.
func (c *ContactClient) Get(ctx context.Context, id uuid.UUID) (*Contact, error) {
	return c.Query().Where(contact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactClient) GetX(ctx context.Context, id uuid.UUID) *Contact {
	co, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return co
}

// QueryOwner queries the owner edge of a Contact.
func (c *ContactClient) QueryOwner(co *Contact) *UserQuery {
	query := &UserQuery{config: c.config}
	id := co.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(contact.Table, contact.FieldID, id),
		sqlgraph.To(user.Table, user.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, contact.OwnerTable, contact.OwnerColumn),
	)
	query.sql = sqlgraph.Neighbors(co.driver.Dialect(), step)

	return query
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Create returns a create builder for Device.
func (c *DeviceClient) Create() *DeviceCreate {
	return &DeviceCreate{config: c.config}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	return &DeviceUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	return c.UpdateOneID(d.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id int) *DeviceUpdateOne {
	return &DeviceUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	return &DeviceDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DeviceClient) DeleteOneID(id int) *DeviceDeleteOne {
	return &DeviceDeleteOne{c.Delete().Where(device.ID(id))}
}

// Create returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{config: c.config}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id int) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id int) *Device {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// DomainClient is a client for the Domain schema.
type DomainClient struct {
	config
}

// NewDomainClient returns a client for the Domain from the given config.
func NewDomainClient(c config) *DomainClient {
	return &DomainClient{config: c}
}

// Create returns a create builder for Domain.
func (c *DomainClient) Create() *DomainCreate {
	return &DomainCreate{config: c.config}
}

// Update returns an update builder for Domain.
func (c *DomainClient) Update() *DomainUpdate {
	return &DomainUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *DomainClient) UpdateOne(d *Domain) *DomainUpdateOne {
	return c.UpdateOneID(d.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *DomainClient) UpdateOneID(id uuid.UUID) *DomainUpdateOne {
	return &DomainUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Domain.
func (c *DomainClient) Delete() *DomainDelete {
	return &DomainDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DomainClient) DeleteOne(d *Domain) *DomainDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DomainClient) DeleteOneID(id uuid.UUID) *DomainDeleteOne {
	return &DomainDeleteOne{c.Delete().Where(domain.ID(id))}
}

// Create returns a query builder for Domain.
func (c *DomainClient) Query() *DomainQuery {
	return &DomainQuery{config: c.config}
}

// Get returns a Domain entity by its id.
func (c *DomainClient) Get(ctx context.Context, id uuid.UUID) (*Domain, error) {
	return c.Query().Where(domain.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DomainClient) GetX(ctx context.Context, id uuid.UUID) *Domain {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// QuerySurveys queries the surveys edge of a Domain.
func (c *DomainClient) QuerySurveys(d *Domain) *SurveyQuery {
	query := &SurveyQuery{config: c.config}
	id := d.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(domain.Table, domain.FieldID, id),
		sqlgraph.To(survey.Table, survey.FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, domain.SurveysTable, domain.SurveysColumn),
	)
	query.sql = sqlgraph.Neighbors(d.driver.Dialect(), step)

	return query
}

// QueryUsers queries the users edge of a Domain.
func (c *DomainClient) QueryUsers(d *Domain) *UserQuery {
	query := &UserQuery{config: c.config}
	id := d.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(domain.Table, domain.FieldID, id),
		sqlgraph.To(user.Table, user.FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, domain.UsersTable, domain.UsersColumn),
	)
	query.sql = sqlgraph.Neighbors(d.driver.Dialect(), step)

	return query
}

// FlowClient is a client for the Flow schema.
type FlowClient struct {
	config
}

// NewFlowClient returns a client for the Flow from the given config.
func NewFlowClient(c config) *FlowClient {
	return &FlowClient{config: c}
}

// Create returns a create builder for Flow.
func (c *FlowClient) Create() *FlowCreate {
	return &FlowCreate{config: c.config}
}

// Update returns an update builder for Flow.
func (c *FlowClient) Update() *FlowUpdate {
	return &FlowUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *FlowClient) UpdateOne(f *Flow) *FlowUpdateOne {
	return c.UpdateOneID(f.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *FlowClient) UpdateOneID(id uuid.UUID) *FlowUpdateOne {
	return &FlowUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Flow.
func (c *FlowClient) Delete() *FlowDelete {
	return &FlowDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FlowClient) DeleteOne(f *Flow) *FlowDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FlowClient) DeleteOneID(id uuid.UUID) *FlowDeleteOne {
	return &FlowDeleteOne{c.Delete().Where(flow.ID(id))}
}

// Create returns a query builder for Flow.
func (c *FlowClient) Query() *FlowQuery {
	return &FlowQuery{config: c.config}
}

// Get returns a Flow entity by its id.
func (c *FlowClient) Get(ctx context.Context, id uuid.UUID) (*Flow, error) {
	return c.Query().Where(flow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FlowClient) GetX(ctx context.Context, id uuid.UUID) *Flow {
	f, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return f
}

// QueryQuestions queries the questions edge of a Flow.
func (c *FlowClient) QueryQuestions(f *Flow) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	id := f.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(flow.Table, flow.FieldID, id),
		sqlgraph.To(question.Table, question.FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, flow.QuestionsTable, flow.QuestionsColumn),
	)
	query.sql = sqlgraph.Neighbors(f.driver.Dialect(), step)

	return query
}

// IPClient is a client for the IP schema.
type IPClient struct {
	config
}

// NewIPClient returns a client for the IP from the given config.
func NewIPClient(c config) *IPClient {
	return &IPClient{config: c}
}

// Create returns a create builder for IP.
func (c *IPClient) Create() *IPCreate {
	return &IPCreate{config: c.config}
}

// Update returns an update builder for IP.
func (c *IPClient) Update() *IPUpdate {
	return &IPUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *IPClient) UpdateOne(i *IP) *IPUpdateOne {
	return c.UpdateOneID(i.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *IPClient) UpdateOneID(id int) *IPUpdateOne {
	return &IPUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for IP.
func (c *IPClient) Delete() *IPDelete {
	return &IPDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *IPClient) DeleteOne(i *IP) *IPDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *IPClient) DeleteOneID(id int) *IPDeleteOne {
	return &IPDeleteOne{c.Delete().Where(ip.ID(id))}
}

// Create returns a query builder for IP.
func (c *IPClient) Query() *IPQuery {
	return &IPQuery{config: c.config}
}

// Get returns a IP entity by its id.
func (c *IPClient) Get(ctx context.Context, id int) (*IP, error) {
	return c.Query().Where(ip.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IPClient) GetX(ctx context.Context, id int) *IP {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// InputClient is a client for the Input schema.
type InputClient struct {
	config
}

// NewInputClient returns a client for the Input from the given config.
func NewInputClient(c config) *InputClient {
	return &InputClient{config: c}
}

// Create returns a create builder for Input.
func (c *InputClient) Create() *InputCreate {
	return &InputCreate{config: c.config}
}

// Update returns an update builder for Input.
func (c *InputClient) Update() *InputUpdate {
	return &InputUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *InputClient) UpdateOne(i *Input) *InputUpdateOne {
	return c.UpdateOneID(i.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *InputClient) UpdateOneID(id uuid.UUID) *InputUpdateOne {
	return &InputUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Input.
func (c *InputClient) Delete() *InputDelete {
	return &InputDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InputClient) DeleteOne(i *Input) *InputDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InputClient) DeleteOneID(id uuid.UUID) *InputDeleteOne {
	return &InputDeleteOne{c.Delete().Where(input.ID(id))}
}

// Create returns a query builder for Input.
func (c *InputClient) Query() *InputQuery {
	return &InputQuery{config: c.config}
}

// Get returns a Input entity by its id.
func (c *InputClient) Get(ctx context.Context, id uuid.UUID) (*Input, error) {
	return c.Query().Where(input.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InputClient) GetX(ctx context.Context, id uuid.UUID) *Input {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// QueryQuestion queries the question edge of a Input.
func (c *InputClient) QueryQuestion(i *Input) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	id := i.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(input.Table, input.FieldID, id),
		sqlgraph.To(question.Table, question.FieldID),
		sqlgraph.Edge(sqlgraph.O2O, true, input.QuestionTable, input.QuestionColumn),
	)
	query.sql = sqlgraph.Neighbors(i.driver.Dialect(), step)

	return query
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Create returns a create builder for Question.
func (c *QuestionClient) Create() *QuestionCreate {
	return &QuestionCreate{config: c.config}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	return &QuestionUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	return c.UpdateOneID(q.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id uuid.UUID) *QuestionUpdateOne {
	return &QuestionUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	return &QuestionDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *QuestionClient) DeleteOneID(id uuid.UUID) *QuestionDeleteOne {
	return &QuestionDeleteOne{c.Delete().Where(question.ID(id))}
}

// Create returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{config: c.config}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id uuid.UUID) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id uuid.UUID) *Question {
	q, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return q
}

// QueryAnswers queries the answers edge of a Question.
func (c *QuestionClient) QueryAnswers(q *Question) *AnswerQuery {
	query := &AnswerQuery{config: c.config}
	id := q.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(question.Table, question.FieldID, id),
		sqlgraph.To(answer.Table, answer.FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, question.AnswersTable, question.AnswersColumn),
	)
	query.sql = sqlgraph.Neighbors(q.driver.Dialect(), step)

	return query
}

// QueryInput queries the input edge of a Question.
func (c *QuestionClient) QueryInput(q *Question) *InputQuery {
	query := &InputQuery{config: c.config}
	id := q.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(question.Table, question.FieldID, id),
		sqlgraph.To(input.Table, input.FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, question.InputTable, question.InputColumn),
	)
	query.sql = sqlgraph.Neighbors(q.driver.Dialect(), step)

	return query
}

// QueryFlow queries the flow edge of a Question.
func (c *QuestionClient) QueryFlow(q *Question) *FlowQuery {
	query := &FlowQuery{config: c.config}
	id := q.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(question.Table, question.FieldID, id),
		sqlgraph.To(flow.Table, flow.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, question.FlowTable, question.FlowColumn),
	)
	query.sql = sqlgraph.Neighbors(q.driver.Dialect(), step)

	return query
}

// SurveyClient is a client for the Survey schema.
type SurveyClient struct {
	config
}

// NewSurveyClient returns a client for the Survey from the given config.
func NewSurveyClient(c config) *SurveyClient {
	return &SurveyClient{config: c}
}

// Create returns a create builder for Survey.
func (c *SurveyClient) Create() *SurveyCreate {
	return &SurveyCreate{config: c.config}
}

// Update returns an update builder for Survey.
func (c *SurveyClient) Update() *SurveyUpdate {
	return &SurveyUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *SurveyClient) UpdateOne(s *Survey) *SurveyUpdateOne {
	return c.UpdateOneID(s.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *SurveyClient) UpdateOneID(id uuid.UUID) *SurveyUpdateOne {
	return &SurveyUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for Survey.
func (c *SurveyClient) Delete() *SurveyDelete {
	return &SurveyDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SurveyClient) DeleteOne(s *Survey) *SurveyDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SurveyClient) DeleteOneID(id uuid.UUID) *SurveyDeleteOne {
	return &SurveyDeleteOne{c.Delete().Where(survey.ID(id))}
}

// Create returns a query builder for Survey.
func (c *SurveyClient) Query() *SurveyQuery {
	return &SurveyQuery{config: c.config}
}

// Get returns a Survey entity by its id.
func (c *SurveyClient) Get(ctx context.Context, id uuid.UUID) (*Survey, error) {
	return c.Query().Where(survey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SurveyClient) GetX(ctx context.Context, id uuid.UUID) *Survey {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryFlow queries the flow edge of a Survey.
func (c *SurveyClient) QueryFlow(s *Survey) *FlowQuery {
	query := &FlowQuery{config: c.config}
	id := s.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(survey.Table, survey.FieldID, id),
		sqlgraph.To(flow.Table, flow.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, survey.FlowTable, survey.FlowColumn),
	)
	query.sql = sqlgraph.Neighbors(s.driver.Dialect(), step)

	return query
}

// QueryFor queries the for edge of a Survey.
func (c *SurveyClient) QueryFor(s *Survey) *UserQuery {
	query := &UserQuery{config: c.config}
	id := s.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(survey.Table, survey.FieldID, id),
		sqlgraph.To(user.Table, user.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, survey.ForTable, survey.ForColumn),
	)
	query.sql = sqlgraph.Neighbors(s.driver.Dialect(), step)

	return query
}

// QueryOwner queries the owner edge of a Survey.
func (c *SurveyClient) QueryOwner(s *Survey) *DomainQuery {
	query := &DomainQuery{config: c.config}
	id := s.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(survey.Table, survey.FieldID, id),
		sqlgraph.To(domain.Table, domain.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, survey.OwnerTable, survey.OwnerColumn),
	)
	query.sql = sqlgraph.Neighbors(s.driver.Dialect(), step)

	return query
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	return &UserCreate{config: c.config}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	return &UserUpdate{config: c.config}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	return c.UpdateOneID(u.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	return &UserUpdateOne{config: c.config, id: id}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	return &UserDelete{config: c.config}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	return &UserDeleteOne{c.Delete().Where(user.ID(id))}
}

// Create returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	u, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return u
}

// QueryAccounts queries the accounts edge of a User.
func (c *UserClient) QueryAccounts(u *User) *AccountQuery {
	query := &AccountQuery{config: c.config}
	id := u.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(user.Table, user.FieldID, id),
		sqlgraph.To(account.Table, account.FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, user.AccountsTable, user.AccountsColumn),
	)
	query.sql = sqlgraph.Neighbors(u.driver.Dialect(), step)

	return query
}

// QueryContacts queries the contacts edge of a User.
func (c *UserClient) QueryContacts(u *User) *ContactQuery {
	query := &ContactQuery{config: c.config}
	id := u.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(user.Table, user.FieldID, id),
		sqlgraph.To(contact.Table, contact.FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, user.ContactsTable, user.ContactsColumn),
	)
	query.sql = sqlgraph.Neighbors(u.driver.Dialect(), step)

	return query
}

// QuerySurveys queries the surveys edge of a User.
func (c *UserClient) QuerySurveys(u *User) *SurveyQuery {
	query := &SurveyQuery{config: c.config}
	id := u.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(user.Table, user.FieldID, id),
		sqlgraph.To(survey.Table, survey.FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, user.SurveysTable, user.SurveysColumn),
	)
	query.sql = sqlgraph.Neighbors(u.driver.Dialect(), step)

	return query
}

// QueryDomain queries the domain edge of a User.
func (c *UserClient) QueryDomain(u *User) *DomainQuery {
	query := &DomainQuery{config: c.config}
	id := u.ID
	step := sqlgraph.NewStep(
		sqlgraph.From(user.Table, user.FieldID, id),
		sqlgraph.To(domain.Table, domain.FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, user.DomainTable, user.DomainColumn),
	)
	query.sql = sqlgraph.Neighbors(u.driver.Dialect(), step)

	return query
}
