// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/minskylab/collecta/ent/migrate"

	"github.com/minskylab/collecta/ent/account"
	"github.com/minskylab/collecta/ent/answer"
	"github.com/minskylab/collecta/ent/contact"
	"github.com/minskylab/collecta/ent/device"
	"github.com/minskylab/collecta/ent/domain"
	"github.com/minskylab/collecta/ent/flow"
	"github.com/minskylab/collecta/ent/input"
	"github.com/minskylab/collecta/ent/ip"
	"github.com/minskylab/collecta/ent/person"
	"github.com/minskylab/collecta/ent/question"
	"github.com/minskylab/collecta/ent/short"
	"github.com/minskylab/collecta/ent/survey"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// Answer is the client for interacting with the Answer builders.
	Answer *AnswerClient
	// Contact is the client for interacting with the Contact builders.
	Contact *ContactClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// Domain is the client for interacting with the Domain builders.
	Domain *DomainClient
	// Flow is the client for interacting with the Flow builders.
	Flow *FlowClient
	// IP is the client for interacting with the IP builders.
	IP *IPClient
	// Input is the client for interacting with the Input builders.
	Input *InputClient
	// Person is the client for interacting with the Person builders.
	Person *PersonClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// Short is the client for interacting with the Short builders.
	Short *ShortClient
	// Survey is the client for interacting with the Survey builders.
	Survey *SurveyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Account = NewAccountClient(c.config)
	c.Answer = NewAnswerClient(c.config)
	c.Contact = NewContactClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.Domain = NewDomainClient(c.config)
	c.Flow = NewFlowClient(c.config)
	c.IP = NewIPClient(c.config)
	c.Input = NewInputClient(c.config)
	c.Person = NewPersonClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.Short = NewShortClient(c.config)
	c.Survey = NewSurveyClient(c.config)
}

// Open opens a connection to the database specified by the driver name and a
// driver-specific data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:   cfg,
		Account:  NewAccountClient(cfg),
		Answer:   NewAnswerClient(cfg),
		Contact:  NewContactClient(cfg),
		Device:   NewDeviceClient(cfg),
		Domain:   NewDomainClient(cfg),
		Flow:     NewFlowClient(cfg),
		IP:       NewIPClient(cfg),
		Input:    NewInputClient(cfg),
		Person:   NewPersonClient(cfg),
		Question: NewQuestionClient(cfg),
		Short:    NewShortClient(cfg),
		Survey:   NewSurveyClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:   cfg,
		Account:  NewAccountClient(cfg),
		Answer:   NewAnswerClient(cfg),
		Contact:  NewContactClient(cfg),
		Device:   NewDeviceClient(cfg),
		Domain:   NewDomainClient(cfg),
		Flow:     NewFlowClient(cfg),
		IP:       NewIPClient(cfg),
		Input:    NewInputClient(cfg),
		Person:   NewPersonClient(cfg),
		Question: NewQuestionClient(cfg),
		Short:    NewShortClient(cfg),
		Survey:   NewSurveyClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Account.Use(hooks...)
	c.Answer.Use(hooks...)
	c.Contact.Use(hooks...)
	c.Device.Use(hooks...)
	c.Domain.Use(hooks...)
	c.Flow.Use(hooks...)
	c.IP.Use(hooks...)
	c.Input.Use(hooks...)
	c.Person.Use(hooks...)
	c.Question.Use(hooks...)
	c.Short.Use(hooks...)
	c.Survey.Use(hooks...)
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Create returns a create builder for Account.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(a *Account) *AccountUpdateOne {
	return c.UpdateOneID(a.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id uuid.UUID) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AccountClient) DeleteOne(a *Account) *AccountDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AccountClient) DeleteOneID(id uuid.UUID) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Create returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{config: c.config}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id uuid.UUID) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id uuid.UUID) *Account {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryOwner queries the owner edge of a Account.
func (c *AccountClient) QueryOwner(a *Account) *PersonQuery {
	query := &PersonQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, account.OwnerTable, account.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// AnswerClient is a client for the Answer schema.
type AnswerClient struct {
	config
}

// NewAnswerClient returns a client for the Answer from the given config.
func NewAnswerClient(c config) *AnswerClient {
	return &AnswerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `answer.Hooks(f(g(h())))`.
func (c *AnswerClient) Use(hooks ...Hook) {
	c.hooks.Answer = append(c.hooks.Answer, hooks...)
}

// Create returns a create builder for Answer.
func (c *AnswerClient) Create() *AnswerCreate {
	mutation := newAnswerMutation(c.config, OpCreate)
	return &AnswerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Answer.
func (c *AnswerClient) Update() *AnswerUpdate {
	mutation := newAnswerMutation(c.config, OpUpdate)
	return &AnswerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnswerClient) UpdateOne(a *Answer) *AnswerUpdateOne {
	return c.UpdateOneID(a.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *AnswerClient) UpdateOneID(id uuid.UUID) *AnswerUpdateOne {
	mutation := newAnswerMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &AnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Answer.
func (c *AnswerClient) Delete() *AnswerDelete {
	mutation := newAnswerMutation(c.config, OpDelete)
	return &AnswerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AnswerClient) DeleteOne(a *Answer) *AnswerDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AnswerClient) DeleteOneID(id uuid.UUID) *AnswerDeleteOne {
	builder := c.Delete().Where(answer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnswerDeleteOne{builder}
}

// Create returns a query builder for Answer.
func (c *AnswerClient) Query() *AnswerQuery {
	return &AnswerQuery{config: c.config}
}

// Get returns a Answer entity by its id.
func (c *AnswerClient) Get(ctx context.Context, id uuid.UUID) (*Answer, error) {
	return c.Query().Where(answer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnswerClient) GetX(ctx context.Context, id uuid.UUID) *Answer {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryQuestion queries the question edge of a Answer.
func (c *AnswerClient) QueryQuestion(a *Answer) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answer.Table, answer.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, answer.QuestionTable, answer.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnswerClient) Hooks() []Hook {
	return c.hooks.Answer
}

// ContactClient is a client for the Contact schema.
type ContactClient struct {
	config
}

// NewContactClient returns a client for the Contact from the given config.
func NewContactClient(c config) *ContactClient {
	return &ContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contact.Hooks(f(g(h())))`.
func (c *ContactClient) Use(hooks ...Hook) {
	c.hooks.Contact = append(c.hooks.Contact, hooks...)
}

// Create returns a create builder for Contact.
func (c *ContactClient) Create() *ContactCreate {
	mutation := newContactMutation(c.config, OpCreate)
	return &ContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Contact.
func (c *ContactClient) Update() *ContactUpdate {
	mutation := newContactMutation(c.config, OpUpdate)
	return &ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactClient) UpdateOne(co *Contact) *ContactUpdateOne {
	return c.UpdateOneID(co.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactClient) UpdateOneID(id uuid.UUID) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contact.
func (c *ContactClient) Delete() *ContactDelete {
	mutation := newContactMutation(c.config, OpDelete)
	return &ContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ContactClient) DeleteOne(co *Contact) *ContactDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ContactClient) DeleteOneID(id uuid.UUID) *ContactDeleteOne {
	builder := c.Delete().Where(contact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactDeleteOne{builder}
}

// Create returns a query builder for Contact.
func (c *ContactClient) Query() *ContactQuery {
	return &ContactQuery{config: c.config}
}

// Get returns a Contact entity by its id.
func (c *ContactClient) Get(ctx context.Context, id uuid.UUID) (*Contact, error) {
	return c.Query().Where(contact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactClient) GetX(ctx context.Context, id uuid.UUID) *Contact {
	co, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return co
}

// QueryOwner queries the owner edge of a Contact.
func (c *ContactClient) QueryOwner(co *Contact) *PersonQuery {
	query := &PersonQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.OwnerTable, contact.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContactClient) Hooks() []Hook {
	return c.hooks.Contact
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Create returns a create builder for Device.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	return c.UpdateOneID(d.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id int) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DeviceClient) DeleteOneID(id int) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Create returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{config: c.config}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id int) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id int) *Device {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	return c.hooks.Device
}

// DomainClient is a client for the Domain schema.
type DomainClient struct {
	config
}

// NewDomainClient returns a client for the Domain from the given config.
func NewDomainClient(c config) *DomainClient {
	return &DomainClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `domain.Hooks(f(g(h())))`.
func (c *DomainClient) Use(hooks ...Hook) {
	c.hooks.Domain = append(c.hooks.Domain, hooks...)
}

// Create returns a create builder for Domain.
func (c *DomainClient) Create() *DomainCreate {
	mutation := newDomainMutation(c.config, OpCreate)
	return &DomainCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Domain.
func (c *DomainClient) Update() *DomainUpdate {
	mutation := newDomainMutation(c.config, OpUpdate)
	return &DomainUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DomainClient) UpdateOne(d *Domain) *DomainUpdateOne {
	return c.UpdateOneID(d.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *DomainClient) UpdateOneID(id uuid.UUID) *DomainUpdateOne {
	mutation := newDomainMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &DomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Domain.
func (c *DomainClient) Delete() *DomainDelete {
	mutation := newDomainMutation(c.config, OpDelete)
	return &DomainDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DomainClient) DeleteOne(d *Domain) *DomainDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DomainClient) DeleteOneID(id uuid.UUID) *DomainDeleteOne {
	builder := c.Delete().Where(domain.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DomainDeleteOne{builder}
}

// Create returns a query builder for Domain.
func (c *DomainClient) Query() *DomainQuery {
	return &DomainQuery{config: c.config}
}

// Get returns a Domain entity by its id.
func (c *DomainClient) Get(ctx context.Context, id uuid.UUID) (*Domain, error) {
	return c.Query().Where(domain.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DomainClient) GetX(ctx context.Context, id uuid.UUID) *Domain {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// QuerySurveys queries the surveys edge of a Domain.
func (c *DomainClient) QuerySurveys(d *Domain) *SurveyQuery {
	query := &SurveyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(survey.Table, survey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, domain.SurveysTable, domain.SurveysColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Domain.
func (c *DomainClient) QueryUsers(d *Domain) *PersonQuery {
	query := &PersonQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, domain.UsersTable, domain.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdmins queries the admins edge of a Domain.
func (c *DomainClient) QueryAdmins(d *Domain) *PersonQuery {
	query := &PersonQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, domain.AdminsTable, domain.AdminsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DomainClient) Hooks() []Hook {
	return c.hooks.Domain
}

// FlowClient is a client for the Flow schema.
type FlowClient struct {
	config
}

// NewFlowClient returns a client for the Flow from the given config.
func NewFlowClient(c config) *FlowClient {
	return &FlowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `flow.Hooks(f(g(h())))`.
func (c *FlowClient) Use(hooks ...Hook) {
	c.hooks.Flow = append(c.hooks.Flow, hooks...)
}

// Create returns a create builder for Flow.
func (c *FlowClient) Create() *FlowCreate {
	mutation := newFlowMutation(c.config, OpCreate)
	return &FlowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Flow.
func (c *FlowClient) Update() *FlowUpdate {
	mutation := newFlowMutation(c.config, OpUpdate)
	return &FlowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FlowClient) UpdateOne(f *Flow) *FlowUpdateOne {
	return c.UpdateOneID(f.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *FlowClient) UpdateOneID(id uuid.UUID) *FlowUpdateOne {
	mutation := newFlowMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &FlowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Flow.
func (c *FlowClient) Delete() *FlowDelete {
	mutation := newFlowMutation(c.config, OpDelete)
	return &FlowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FlowClient) DeleteOne(f *Flow) *FlowDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FlowClient) DeleteOneID(id uuid.UUID) *FlowDeleteOne {
	builder := c.Delete().Where(flow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FlowDeleteOne{builder}
}

// Create returns a query builder for Flow.
func (c *FlowClient) Query() *FlowQuery {
	return &FlowQuery{config: c.config}
}

// Get returns a Flow entity by its id.
func (c *FlowClient) Get(ctx context.Context, id uuid.UUID) (*Flow, error) {
	return c.Query().Where(flow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FlowClient) GetX(ctx context.Context, id uuid.UUID) *Flow {
	f, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return f
}

// QuerySurvey queries the survey edge of a Flow.
func (c *FlowClient) QuerySurvey(f *Flow) *SurveyQuery {
	query := &SurveyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flow.Table, flow.FieldID, id),
			sqlgraph.To(survey.Table, survey.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, flow.SurveyTable, flow.SurveyColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a Flow.
func (c *FlowClient) QueryQuestions(f *Flow) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flow.Table, flow.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, flow.QuestionsTable, flow.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FlowClient) Hooks() []Hook {
	return c.hooks.Flow
}

// IPClient is a client for the IP schema.
type IPClient struct {
	config
}

// NewIPClient returns a client for the IP from the given config.
func NewIPClient(c config) *IPClient {
	return &IPClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ip.Hooks(f(g(h())))`.
func (c *IPClient) Use(hooks ...Hook) {
	c.hooks.IP = append(c.hooks.IP, hooks...)
}

// Create returns a create builder for IP.
func (c *IPClient) Create() *IPCreate {
	mutation := newIPMutation(c.config, OpCreate)
	return &IPCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for IP.
func (c *IPClient) Update() *IPUpdate {
	mutation := newIPMutation(c.config, OpUpdate)
	return &IPUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IPClient) UpdateOne(i *IP) *IPUpdateOne {
	return c.UpdateOneID(i.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *IPClient) UpdateOneID(id int) *IPUpdateOne {
	mutation := newIPMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &IPUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IP.
func (c *IPClient) Delete() *IPDelete {
	mutation := newIPMutation(c.config, OpDelete)
	return &IPDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *IPClient) DeleteOne(i *IP) *IPDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *IPClient) DeleteOneID(id int) *IPDeleteOne {
	builder := c.Delete().Where(ip.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IPDeleteOne{builder}
}

// Create returns a query builder for IP.
func (c *IPClient) Query() *IPQuery {
	return &IPQuery{config: c.config}
}

// Get returns a IP entity by its id.
func (c *IPClient) Get(ctx context.Context, id int) (*IP, error) {
	return c.Query().Where(ip.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IPClient) GetX(ctx context.Context, id int) *IP {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// Hooks returns the client hooks.
func (c *IPClient) Hooks() []Hook {
	return c.hooks.IP
}

// InputClient is a client for the Input schema.
type InputClient struct {
	config
}

// NewInputClient returns a client for the Input from the given config.
func NewInputClient(c config) *InputClient {
	return &InputClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `input.Hooks(f(g(h())))`.
func (c *InputClient) Use(hooks ...Hook) {
	c.hooks.Input = append(c.hooks.Input, hooks...)
}

// Create returns a create builder for Input.
func (c *InputClient) Create() *InputCreate {
	mutation := newInputMutation(c.config, OpCreate)
	return &InputCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Input.
func (c *InputClient) Update() *InputUpdate {
	mutation := newInputMutation(c.config, OpUpdate)
	return &InputUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InputClient) UpdateOne(i *Input) *InputUpdateOne {
	return c.UpdateOneID(i.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *InputClient) UpdateOneID(id uuid.UUID) *InputUpdateOne {
	mutation := newInputMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &InputUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Input.
func (c *InputClient) Delete() *InputDelete {
	mutation := newInputMutation(c.config, OpDelete)
	return &InputDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InputClient) DeleteOne(i *Input) *InputDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InputClient) DeleteOneID(id uuid.UUID) *InputDeleteOne {
	builder := c.Delete().Where(input.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InputDeleteOne{builder}
}

// Create returns a query builder for Input.
func (c *InputClient) Query() *InputQuery {
	return &InputQuery{config: c.config}
}

// Get returns a Input entity by its id.
func (c *InputClient) Get(ctx context.Context, id uuid.UUID) (*Input, error) {
	return c.Query().Where(input.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InputClient) GetX(ctx context.Context, id uuid.UUID) *Input {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// QueryQuestion queries the question edge of a Input.
func (c *InputClient) QueryQuestion(i *Input) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(input.Table, input.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, input.QuestionTable, input.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InputClient) Hooks() []Hook {
	return c.hooks.Input
}

// PersonClient is a client for the Person schema.
type PersonClient struct {
	config
}

// NewPersonClient returns a client for the Person from the given config.
func NewPersonClient(c config) *PersonClient {
	return &PersonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `person.Hooks(f(g(h())))`.
func (c *PersonClient) Use(hooks ...Hook) {
	c.hooks.Person = append(c.hooks.Person, hooks...)
}

// Create returns a create builder for Person.
func (c *PersonClient) Create() *PersonCreate {
	mutation := newPersonMutation(c.config, OpCreate)
	return &PersonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Person.
func (c *PersonClient) Update() *PersonUpdate {
	mutation := newPersonMutation(c.config, OpUpdate)
	return &PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonClient) UpdateOne(pe *Person) *PersonUpdateOne {
	return c.UpdateOneID(pe.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonClient) UpdateOneID(id uuid.UUID) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Person.
func (c *PersonClient) Delete() *PersonDelete {
	mutation := newPersonMutation(c.config, OpDelete)
	return &PersonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PersonClient) DeleteOne(pe *Person) *PersonDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PersonClient) DeleteOneID(id uuid.UUID) *PersonDeleteOne {
	builder := c.Delete().Where(person.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonDeleteOne{builder}
}

// Create returns a query builder for Person.
func (c *PersonClient) Query() *PersonQuery {
	return &PersonQuery{config: c.config}
}

// Get returns a Person entity by its id.
func (c *PersonClient) Get(ctx context.Context, id uuid.UUID) (*Person, error) {
	return c.Query().Where(person.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonClient) GetX(ctx context.Context, id uuid.UUID) *Person {
	pe, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pe
}

// QueryAccounts queries the accounts edge of a Person.
func (c *PersonClient) QueryAccounts(pe *Person) *AccountQuery {
	query := &AccountQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.AccountsTable, person.AccountsColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContacts queries the contacts edge of a Person.
func (c *PersonClient) QueryContacts(pe *Person) *ContactQuery {
	query := &ContactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.ContactsTable, person.ContactsColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySurveys queries the surveys edge of a Person.
func (c *PersonClient) QuerySurveys(pe *Person) *SurveyQuery {
	query := &SurveyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(survey.Table, survey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.SurveysTable, person.SurveysColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDomains queries the domains edge of a Person.
func (c *PersonClient) QueryDomains(pe *Person) *DomainQuery {
	query := &DomainQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(domain.Table, domain.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, person.DomainsTable, person.DomainsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdminOf queries the adminOf edge of a Person.
func (c *PersonClient) QueryAdminOf(pe *Person) *DomainQuery {
	query := &DomainQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(domain.Table, domain.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, person.AdminOfTable, person.AdminOfPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonClient) Hooks() []Hook {
	return c.hooks.Person
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Create returns a create builder for Question.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	return c.UpdateOneID(q.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id uuid.UUID) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *QuestionClient) DeleteOneID(id uuid.UUID) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Create returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{config: c.config}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id uuid.UUID) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id uuid.UUID) *Question {
	q, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return q
}

// QueryAnswers queries the answers edge of a Question.
func (c *QuestionClient) QueryAnswers(q *Question) *AnswerQuery {
	query := &AnswerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(answer.Table, answer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.AnswersTable, question.AnswersColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInput queries the input edge of a Question.
func (c *QuestionClient) QueryInput(q *Question) *InputQuery {
	query := &InputQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(input.Table, input.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, question.InputTable, question.InputColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlow queries the flow edge of a Question.
func (c *QuestionClient) QueryFlow(q *Question) *FlowQuery {
	query := &FlowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(flow.Table, flow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.FlowTable, question.FlowColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// ShortClient is a client for the Short schema.
type ShortClient struct {
	config
}

// NewShortClient returns a client for the Short from the given config.
func NewShortClient(c config) *ShortClient {
	return &ShortClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `short.Hooks(f(g(h())))`.
func (c *ShortClient) Use(hooks ...Hook) {
	c.hooks.Short = append(c.hooks.Short, hooks...)
}

// Create returns a create builder for Short.
func (c *ShortClient) Create() *ShortCreate {
	mutation := newShortMutation(c.config, OpCreate)
	return &ShortCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Short.
func (c *ShortClient) Update() *ShortUpdate {
	mutation := newShortMutation(c.config, OpUpdate)
	return &ShortUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShortClient) UpdateOne(s *Short) *ShortUpdateOne {
	return c.UpdateOneID(s.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *ShortClient) UpdateOneID(id int) *ShortUpdateOne {
	mutation := newShortMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &ShortUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Short.
func (c *ShortClient) Delete() *ShortDelete {
	mutation := newShortMutation(c.config, OpDelete)
	return &ShortDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ShortClient) DeleteOne(s *Short) *ShortDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ShortClient) DeleteOneID(id int) *ShortDeleteOne {
	builder := c.Delete().Where(short.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShortDeleteOne{builder}
}

// Create returns a query builder for Short.
func (c *ShortClient) Query() *ShortQuery {
	return &ShortQuery{config: c.config}
}

// Get returns a Short entity by its id.
func (c *ShortClient) Get(ctx context.Context, id int) (*Short, error) {
	return c.Query().Where(short.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShortClient) GetX(ctx context.Context, id int) *Short {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// Hooks returns the client hooks.
func (c *ShortClient) Hooks() []Hook {
	return c.hooks.Short
}

// SurveyClient is a client for the Survey schema.
type SurveyClient struct {
	config
}

// NewSurveyClient returns a client for the Survey from the given config.
func NewSurveyClient(c config) *SurveyClient {
	return &SurveyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `survey.Hooks(f(g(h())))`.
func (c *SurveyClient) Use(hooks ...Hook) {
	c.hooks.Survey = append(c.hooks.Survey, hooks...)
}

// Create returns a create builder for Survey.
func (c *SurveyClient) Create() *SurveyCreate {
	mutation := newSurveyMutation(c.config, OpCreate)
	return &SurveyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Survey.
func (c *SurveyClient) Update() *SurveyUpdate {
	mutation := newSurveyMutation(c.config, OpUpdate)
	return &SurveyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SurveyClient) UpdateOne(s *Survey) *SurveyUpdateOne {
	return c.UpdateOneID(s.ID)
}

// UpdateOneID returns an update builder for the given id.
func (c *SurveyClient) UpdateOneID(id uuid.UUID) *SurveyUpdateOne {
	mutation := newSurveyMutation(c.config, OpUpdateOne)
	mutation.id = &id
	return &SurveyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Survey.
func (c *SurveyClient) Delete() *SurveyDelete {
	mutation := newSurveyMutation(c.config, OpDelete)
	return &SurveyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SurveyClient) DeleteOne(s *Survey) *SurveyDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SurveyClient) DeleteOneID(id uuid.UUID) *SurveyDeleteOne {
	builder := c.Delete().Where(survey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SurveyDeleteOne{builder}
}

// Create returns a query builder for Survey.
func (c *SurveyClient) Query() *SurveyQuery {
	return &SurveyQuery{config: c.config}
}

// Get returns a Survey entity by its id.
func (c *SurveyClient) Get(ctx context.Context, id uuid.UUID) (*Survey, error) {
	return c.Query().Where(survey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SurveyClient) GetX(ctx context.Context, id uuid.UUID) *Survey {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryFlow queries the flow edge of a Survey.
func (c *SurveyClient) QueryFlow(s *Survey) *FlowQuery {
	query := &FlowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(survey.Table, survey.FieldID, id),
			sqlgraph.To(flow.Table, flow.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, survey.FlowTable, survey.FlowColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFor queries the for edge of a Survey.
func (c *SurveyClient) QueryFor(s *Survey) *PersonQuery {
	query := &PersonQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(survey.Table, survey.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, survey.ForTable, survey.ForColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Survey.
func (c *SurveyClient) QueryOwner(s *Survey) *DomainQuery {
	query := &DomainQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(survey.Table, survey.FieldID, id),
			sqlgraph.To(domain.Table, domain.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, survey.OwnerTable, survey.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SurveyClient) Hooks() []Hook {
	return c.hooks.Survey
}
