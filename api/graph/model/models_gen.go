// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Account struct {
	ID       string      `json:"id"`
	Type     AccountType `json:"type"`
	Sub      string      `json:"sub"`
	RemoteID string      `json:"remoteID"`
	Secret   *string     `json:"secret"`
	Owner    *Person     `json:"owner"`
}

type Answer struct {
	ID        string    `json:"id"`
	At        time.Time `json:"at"`
	Responses []string  `json:"responses"`
	Valid     *bool     `json:"valid"`
	Question  *Question `json:"question"`
}

type Contact struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	Value       string      `json:"value"`
	Kind        ContactKind `json:"kind"`
	Principal   bool        `json:"principal"`
	Validated   bool        `json:"validated"`
	FromAccount bool        `json:"fromAccount"`
	Owner       *Person     `json:"owner"`
}

type Device struct {
	Device string `json:"device"`
}

type Domain struct {
	ID                     string    `json:"id"`
	Name                   string    `json:"name"`
	Email                  string    `json:"email"`
	Domain                 string    `json:"domain"`
	CollectaDomain         string    `json:"collectaDomain"`
	CollectaClientCallback string    `json:"collectaClientCallback"`
	Tags                   []string  `json:"tags"`
	Surveys                []*Survey `json:"surveys"`
	Users                  []*Person `json:"users"`
	Admins                 []*Person `json:"admins"`
}

type DomainCreator struct {
	Name           string   `json:"name"`
	Email          string   `json:"email"`
	Domain         string   `json:"domain"`
	CollectaDomain string   `json:"collectaDomain"`
	Tags           []string `json:"tags"`
}

type Flow struct {
	ID               string      `json:"id"`
	State            string      `json:"state"`
	StateTable       string      `json:"stateTable"`
	InitialState     string      `json:"initialState"`
	TerminationState string      `json:"terminationState"`
	PastState        *string     `json:"pastState"`
	Inputs           []string    `json:"inputs"`
	Survey           *Survey     `json:"survey"`
	Questions        []*Question `json:"questions"`
}

type IP struct {
	IP string `json:"ip"`
}

type Input struct {
	ID       string    `json:"id"`
	Kind     InputKind `json:"kind"`
	Multiple *bool     `json:"multiple"`
	Defaults []string  `json:"defaults"`
	Options  *Map      `json:"options"`
	Question *Question `json:"question"`
}

type LastSurveyState struct {
	LastQuestion *Question `json:"lastQuestion"`
	Percent      float64   `json:"percent"`
}

type LoginResponse struct {
	Token string `json:"token"`
}

type Map struct {
	Content []*PairMap `json:"content"`
}

type Pair struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type PairMap struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type Person struct {
	ID           string     `json:"id"`
	Name         string     `json:"name"`
	LastActivity time.Time  `json:"lastActivity"`
	Username     *string    `json:"username"`
	Picture      *string    `json:"picture"`
	Roles        []string   `json:"roles"`
	Accounts     []*Account `json:"accounts"`
	Contacts     []*Contact `json:"contacts"`
	Surveys      []*Survey  `json:"surveys"`
	Domains      []*Domain  `json:"domains"`
	AdminOf      []*Domain  `json:"adminOf"`
}

type Question struct {
	ID          string    `json:"id"`
	Hash        string    `json:"hash"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Metadata    *Map      `json:"metadata"`
	Validator   *string   `json:"validator"`
	Anonymous   bool      `json:"anonymous"`
	Answers     []*Answer `json:"answers"`
	Input       *Input    `json:"input"`
	Flow        *Flow     `json:"flow"`
}

type QuestionCreator struct {
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Kind        InputType `json:"kind"`
	Multiple    *bool     `json:"multiple"`
	Anonymous   *bool     `json:"anonymous"`
	Options     []*Pair   `json:"options"`
}

type Short struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type Survey struct {
	ID              string    `json:"id"`
	Tags            []string  `json:"tags"`
	LastInteraction time.Time `json:"lastInteraction"`
	DueDate         time.Time `json:"dueDate"`
	Title           string    `json:"title"`
	Description     *string   `json:"description"`
	Metadata        *Map      `json:"metadata"`
	Done            *bool     `json:"done"`
	IsPublic        *bool     `json:"isPublic"`
	Flow            *Flow     `json:"flow"`
	For             *Person   `json:"for"`
	Owner           *Domain   `json:"owner"`
}

type SurveyDomain struct {
	ByID         *string `json:"byID"`
	ByDomainName *string `json:"byDomainName"`
}

type SurveyGenerator struct {
	Title       string             `json:"title"`
	Description string             `json:"description"`
	Tags        []string           `json:"tags"`
	Questions   []*QuestionCreator `json:"questions"`
	Target      *SurveyTargetUsers `json:"target"`
	Metadata    []*Pair            `json:"metadata"`
	Logic       *string            `json:"logic"`
	Due         *time.Time         `json:"due"`
}

type SurveyTargetUsers struct {
	TargetKind SurveyAudenceKind `json:"targetKind"`
	Whitelist  []string          `json:"whitelist"`
}

type SuveyGenerationResult struct {
	How     int       `json:"how"`
	Surveys []*Survey `json:"surveys"`
}

type AccountType string

const (
	AccountTypeGoogle    AccountType = "Google"
	AccountTypeAnonymous AccountType = "Anonymous"
	AccountTypeEmail     AccountType = "Email"
)

var AllAccountType = []AccountType{
	AccountTypeGoogle,
	AccountTypeAnonymous,
	AccountTypeEmail,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeGoogle, AccountTypeAnonymous, AccountTypeEmail:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContactKind string

const (
	ContactKindEmail ContactKind = "Email"
	ContactKindPhone ContactKind = "Phone"
)

var AllContactKind = []ContactKind{
	ContactKindEmail,
	ContactKindPhone,
}

func (e ContactKind) IsValid() bool {
	switch e {
	case ContactKindEmail, ContactKindPhone:
		return true
	}
	return false
}

func (e ContactKind) String() string {
	return string(e)
}

func (e *ContactKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContactKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContactKind", str)
	}
	return nil
}

func (e ContactKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InputKind string

const (
	InputKindText         InputKind = "Text"
	InputKindOptions      InputKind = "Options"
	InputKindSatisfaction InputKind = "Satisfaction"
	InputKindBoolean      InputKind = "Boolean"
)

var AllInputKind = []InputKind{
	InputKindText,
	InputKindOptions,
	InputKindSatisfaction,
	InputKindBoolean,
}

func (e InputKind) IsValid() bool {
	switch e {
	case InputKindText, InputKindOptions, InputKindSatisfaction, InputKindBoolean:
		return true
	}
	return false
}

func (e InputKind) String() string {
	return string(e)
}

func (e *InputKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InputKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InputKind", str)
	}
	return nil
}

func (e InputKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InputType string

const (
	InputTypeOption       InputType = "OPTION"
	InputTypeText         InputType = "TEXT"
	InputTypeBoolean      InputType = "BOOLEAN"
	InputTypeSatisfaction InputType = "SATISFACTION"
)

var AllInputType = []InputType{
	InputTypeOption,
	InputTypeText,
	InputTypeBoolean,
	InputTypeSatisfaction,
}

func (e InputType) IsValid() bool {
	switch e {
	case InputTypeOption, InputTypeText, InputTypeBoolean, InputTypeSatisfaction:
		return true
	}
	return false
}

func (e InputType) String() string {
	return string(e)
}

func (e *InputType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InputType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InputType", str)
	}
	return nil
}

func (e InputType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SurveyAudenceKind string

const (
	SurveyAudenceKindPublic SurveyAudenceKind = "PUBLIC"
	SurveyAudenceKindDomain SurveyAudenceKind = "DOMAIN"
	SurveyAudenceKindClose  SurveyAudenceKind = "CLOSE"
)

var AllSurveyAudenceKind = []SurveyAudenceKind{
	SurveyAudenceKindPublic,
	SurveyAudenceKindDomain,
	SurveyAudenceKindClose,
}

func (e SurveyAudenceKind) IsValid() bool {
	switch e {
	case SurveyAudenceKindPublic, SurveyAudenceKindDomain, SurveyAudenceKindClose:
		return true
	}
	return false
}

func (e SurveyAudenceKind) String() string {
	return string(e)
}

func (e *SurveyAudenceKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SurveyAudenceKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SurveyAudenceKind", str)
	}
	return nil
}

func (e SurveyAudenceKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
